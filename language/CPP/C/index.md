---
html:
    toc: true   # 打开侧边目录
export_on_save:
    html: true  # 自动保存
---

# C是如何工作的

对于这个问题，
* 通俗的，计算机是如何看懂我给它下达的指令。
* 具体的，如何把 `.c` （文本文件） -> `.exe` （可执行文件） 

**源文件 -> 预处理 -> 编译 -> 汇编 -> 链接 -> 可执行文件**

<br>

## 预处理

* 一个文本替换工具罢了，它会根据源文件中的预处理指令，修改源文件。
* 预处理指令以 `#` 开头，如 `#include`、`#define` 等。
    * `#include` 会把指定的文件内容插入到当前文件中。
    * `#define` （宏定义）会把指定的内容替换到当前文件中。
        ```cpp
        #define MAX 100

        int a[MAX];             // int a[100]; 定义一个大小为 100 的数组
        printf("%d", MAX*MAX);  // printf("%d", 100*100); 输出 10000
        ```
        **值得注意的是，宏定义只是简单的文本替换**
        
        C语言自带一些宏定义：`__TIME__`，`__FILE__` 等等
        ```cpp
        printf("%s", __TIME__);    // 输出当前（预处理器替换时候的）时间
        printf("%s", __FILE__);    // 输出当前文件名
        ```

    更多内容可以参考：[C语言预处理器](https://www.runoob.com/cprogramming/c-preprocessors.html)

    <br>

* 预处理后的文件，以 `.i` 为后缀名，如 `main.i`。

    1. 源文件 `main.c`
        ```cpp
        #include <stdio.h>
        #define MAX 100

        int main(){
            int a[MAX];
            printf("%d", MAX*MAX);
        }
        ```

    2. 使用 gcc 生成预处理后的文件 `main.i`
        ```bash
        gcc -E main.c -o main.i
        ```


<br>

## 编译

* 编译器会把预处理后的文件，翻译成汇编语言。
    * 一种低级语言，它使用助记符（mnemonic）代替二进制指令。
    * 汇编语言是与硬件相关的，不同的硬件有不同的汇编语言。
* 汇编语言以 `.s` 为后缀名，如 `main.s`。
    1. 使用 gcc 生成汇编文件 `main.s`
        ```bash
        gcc -S main.i -o main.s
        ```


<br>

## 汇编

* 汇编器会把汇编语言翻译成机器语言。
    * 机器语言，使用二进制指令。

* 机器语言以 `.o` 为后缀名，如 `main.o`。
    1. 使用 gcc 生成目标文件 `main.o`
        ```bash
        gcc -c main.s -o main.o
        ```


<br>

## 链接

* 链接器将多个汇编文件链接成一个可执行文件。

* 在 linux 中，可执行文件以 `.out` 为后缀名，如 `main.out`。
    1. 使用 gcc 生成可执行文件 `main.out`
        ```bash
        gcc main.o -o main.out
        ```

* 现在有 `a.c` 文件和 `b.c` 文件
    * `a.c`
        ```c
        #include <stdio.h>

        int main(){
            printf("%d", ADD(2, 3));
            return 0;
        }
        ```
    * `b.c`
        ```c
        #include <stdio.h>

        int ADD(int a, int b){
            return a + b;
        }
        ```

    1. 使用 gcc 生成 `.o` 文件
        ```bash
        gcc -c a.c -o a.o
        ```
        此时，`a.o` 中的 `main` 函数调用了 `ADD` 函数，但是 `ADD` 函数的定义并没有找到。弹出了一个警告。
        **注意，`gcc` 只检查语法，不检查函数的定义。**
        **注意，`g++` 会检查函数的定义，它会在这里弹出错误。**
    
        ```bash
        gcc -c b.c -o b.o
        ```



    2. 使用 gcc 生成可执行文件
        ```bash
        gcc a.o b.o -o main.out
        ```
        **注意，链接器会检查函数的定义，如果找不到定义，就会报错。**


<br>

至此，我们不仅知道 C 工作的原理，还在一定程度上了解 `.h`，`.c` 文件的关系
    

<br>

---

# 编译器是如何工作的

## todo 

<br>

---

# 链接器是如何工作的

## todo

<br>

---

# 基本数据类型

在 C 中，有以下几种基本数据类型：

## 整型

| 类型 | 字节数 | signed | unsigned |
|:-:|:-:|:-:|:-:|
| `short`    | 2      | \(-2^{15}\) 到 \(2^{15} - 1\) `%hd`  | 0 到 \(2^{16} - 1\) `%hu` |
| `int`      | 4      | \(-2^{31}\) 到 \(2^{31} - 1\) `%d`  | 0 到 \(2^{32} - 1\) `%u` |
| `long long`| 8      | \(-2^{63}\) 到 \(2^{63} - 1\) `%lld`  | 0 到 \(2^{64} - 1\) `%llu`|

特别的，为了兼容性，有了精确宽度整数类型（exact-width integers types）的定义。

`#include <stdint.h>`

| 类型 | 字节数 | signed | unsigned |
|:-:|:-:|:-:|:-:|
|`int8_t`|1| \(-2^{7}\) 到 \(2^{7} - 1\) | 0 到 \(2^{8} - 1\) |
|`int16_t`|2| \(-2^{15}\) 到 \(2^{15} - 1\) | 0 到 \(2^{16} - 1\) |
|`int32_t`|4| \(-2^{31}\) 到 \(2^{31} - 1\) | 0 到 \(2^{32} - 1\) |
|`int64_t`|8| \(-2^{63}\) 到 \(2^{63} - 1\) | 0 到 \(2^{64} - 1\) |

特别的，GCC编译器还支持 `__int128_t` 类型，即128位整型。

遗憾的，因为是编译器扩展，所以不是标准的C语言，无法直接 printf。

## 浮点型

| 类型 | 字节数 | 精度 | 格式化 |
|:-:|:-:|:-:|:-:|
| `float`    | 4      | $10^{-7}$ | `%f` |
| `double`   | 8      | $10^{-15}$ | `%lf` |

## 字符型

| 类型 | 字节数 | 格式化 |
|:-:|:-:|:-:|
| `char` | 1 | `%c` |

常用的 ASCII 码表：

| 字符 | ASCII 码 |
|:-:|:-:|
| `\0`| 0 |
| `0` | 48 |
| `A` | 65 |
| `a` | 97 |

## 指针

指针也是一种数据类型，它用于存储内存地址。

| 类型 | 字节数 | 格式化 |
|:-:|:-:|:-:|
| `void *` | 8 | `%p` |

和其他数据类型一样
* `int` 存储数字
* `char` 存储字符
* `double` 存储浮点数
* **`void *` 存储内存地址**

**那为何有 `char *`、`int *`、`double *` 等类型呢？**
**指明指针指向的数据类型：**
1. 指针的算术操作
    不同类型的指针运算时，步长不同。
    * `char` 占用 1 字节， `char *` 步长为 1。
        ```cpp
        char c = '6';   // c 的地址为 0xa
        char *p = c;    // p 的 值 为 0xa
        p = p + 1;      // p 的 值 为 0xb
        ```

    * `int` 占用 4 字节， `int *` 步长为 4。
        ```cpp
        int i = 6;      // i 的地址为 0x1
        int *p = i;     // p 的 值 为 0x1
        p = p + 1;      // p 的 值 为 0x5
        ```

2. 类型安全
    编译器会在编译时检查指针的类型，
    从而避免不同类型的指针直接赋值或比较，
    确保了在程序中正确使用指针。

```c
#include <stdio.h>

int main(){
    char c = '6';
    char t = '?';
    char *p = &c;

    // 变量 c 的值
    // 变量 c 的地址
    // 指针 p 的值
    // 指针 p 的地址
    // 通过指针 p 访问变量 c 的值
    printf("\nc                &c               p                &p               *p\n");
    printf("%-16c %-16p %-16p %-16p %-16c\n\n", c, &c, p, &p, *p);

    printf("\n                 &c+1             p+1              &p+1             *(p+1)\n");
    printf("%-16c %-16p %-16p %-16p %-16c\n\n", ' ', &c+1, p+1, &p+1, *(p+1));

    scanf("%c", p+1);

    printf("\n                 &c+1             p+1              &p+1             *(p+1)\n");
    printf("%-16c %-16p %-16p %-16p %-16c\n\n", ' ', &c+1, p+1, &p+1, *(p+1));

    printf("%c", t);
}
```

## 聚合类型

聚合类型是由多个基本类型组成的数据类型。

**数组**

数组的本质是一段连续的内存空间，数组名是数组首元素的地址。







**结构体**

* 数组：多个 **相同** 元素的集合
* 结构体：多个 **不同** 的元素的集合

