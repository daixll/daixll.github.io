---
html:
    toc: true   # 打开侧边目录
export_on_save:
    html: true  # 自动保存
---

# 参考

关于 C/C++ 的学习参考：

1. 学习 **基本语法**：最快速的上手方式是国内自学网站 [菜鸟教程](https://www.runoob.com/cplusplus/cpp-tutorial.html) 等 + [洛谷OJ](https://www.luogu.com.cn/training/list) 等，再看看视频等。
    * 视频推荐：[【Youtube】 The Cherno](https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb) / [【bilibili】 The Cherno(搬运)](https://www.bilibili.com/video/BV1oD4y1h7S3)
    * 洛谷OJ 只需要完成入门系列的题目即可，但如果你未来想要更好的从事开发相关的工作，建议开始 **系统地** 学习数据结构与算法，同时，对网络、OS、数据库等方面也要有一定的了解。
    * 学有余力，可以看看《C++ Primer》 、《C 和指针》等书籍。

<br>

2. 学习 **C++ STL**：如果你有数据结构和算法的基础，其实也就不必再学习 C++ STL 了，因为 C++ STL 本质上就是数据结构和算法的实现。
    * [C语言中文网：C++ STL快速入门](https://c.biancheng.net/stl/)
    * 书籍：侯捷 - 《STL源码剖析》

<br>

3. 学习 **现代C++** C++ 11/14/17/20：这是一个非常庞大的话题，涉及了很多方面，最高效的方式是看书。
    * 优先学习新特性，或者说，优先学习新特性的使用方法，而不是去了解新特性的实现原理。
    * **网络编程** 和 **并发编程** 部分，建议单独学习。
    * 推荐阅读：[现代 C++ 教程](https://changkun.de/modern-cpp/)、《C++ XX高级编程》、《现代C++ 白皮书》（课外阅读）。
    * 近期出版的《C++ 之旅（第三版）》、《C++ Core Guildelines解析》也是非常不错的书籍。

<br>

4. 学习 **面向对象**：用C++之父 本贾尼 的话说，C++是支持面向对象，而不是，C++是面向对象的语言。*“面向对象不是 C++ 的所有，而仅仅是其支持的多种编程范式（面向过程、面向对象、泛型编程、函数式编程）中的一种”*。
    * 面向对象编程：封装、继承、多态。
    * 既然面向对象是一种思想，我们应该跳脱出语言的限制，去思考如何设计一个面向对象的系统。
    * [书籍参考]()：《设计模式的艺术——软件开发人员内功修炼之道》、《head first设计模式》。
    * 架构为道、设计为术。设计模式是确定架构下的最佳实践。



<br>

---

# C是如何工作的

对于这个问题，
* 通俗的，计算机是如何看懂我给它下达的指令。
* 具体的，如何把 `.c` （文本文件） -> `.exe` （可执行文件） 

**源文件 -> 预处理 -> 编译 -> 汇编 -> 链接 -> 可执行文件**

<br>

## 预处理

* 一个文本替换工具罢了，它会根据源文件中的预处理指令，修改源文件。
* 预处理指令以 `#` 开头，如 `#include`、`#define` 等。
    * `#include` 会把指定的文件内容插入到当前文件中。
    * `#define` （宏定义）会把指定的内容替换到当前文件中。
        ```cpp
        #define MAX 100

        int a[MAX];             // int a[100]; 定义一个大小为 100 的数组
        printf("%d", MAX*MAX);  // printf("%d", 100*100); 输出 10000
        ```
        **值得注意的是，宏定义只是简单的文本替换**
        
        C语言自带一些宏定义：`__TIME__`，`__FILE__` 等等
        ```cpp
        printf("%s", __TIME__);    // 输出当前（预处理器替换时候的）时间
        printf("%s", __FILE__);    // 输出当前文件名
        ```

    更多内容可以参考：[C语言预处理器](https://www.runoob.com/cprogramming/c-preprocessors.html)

    <br>

* 预处理后的文件，以 `.i` 为后缀名，如 `main.i`。

    1. 源文件 `main.c`
        ```cpp
        #include <stdio.h>
        #define MAX 100

        int main(){
            int a[MAX];
            printf("%d", MAX*MAX);
        }
        ```

    2. 使用 gcc 生成预处理后的文件 `main.i`
        ```bash
        gcc -E main.c -o main.i
        ```


<br>

## 编译

* 编译器会把预处理后的文件，翻译成汇编语言。
    * 一种低级语言，它使用助记符（mnemonic）代替二进制指令。
    * 汇编语言是与硬件相关的，不同的硬件有不同的汇编语言。
* 汇编语言以 `.s` 为后缀名，如 `main.s`。
    1. 使用 gcc 生成汇编文件 `main.s`
        ```bash
        gcc -S main.i -o main.s
        ```


<br>

## 汇编

* 汇编器会把汇编语言翻译成机器语言。
    * 机器语言，使用二进制指令。

* 机器语言以 `.o` 为后缀名，如 `main.o`。
    1. 使用 gcc 生成目标文件 `main.o`
        ```bash
        gcc -c main.s -o main.o
        ```


<br>

## 链接

* 链接器将多个汇编文件链接成一个可执行文件。

* 在 linux 中，可执行文件以 `.out` 为后缀名，如 `main.out`。
    1. 使用 gcc 生成可执行文件 `main.out`
        ```bash
        gcc main.o -o main.out
        ```

* 现在有 `a.c` 文件和 `b.c` 文件
    * `a.c`
        ```c
        #include <stdio.h>

        int main(){
            printf("%d", ADD(2, 3));
            return 0;
        }
        ```
    * `b.c`
        ```c
        #include <stdio.h>

        int ADD(int a, int b){
            return a + b;
        }
        ```

    1. 使用 gcc 生成 `.o` 文件
        ```bash
        gcc -c a.c -o a.o
        ```
        此时，`a.o` 中的 `main` 函数调用了 `ADD` 函数，但是 `ADD` 函数的定义并没有找到。弹出了一个警告。
        **注意，`gcc` 只检查语法，不检查函数的定义。**
        **注意，`g++` 会检查函数的定义，它会在这里弹出错误。**
    
        ```bash
        gcc -c b.c -o b.o
        ```



    2. 使用 gcc 生成可执行文件
        ```bash
        gcc a.o b.o -o main.out
        ```
        **注意，链接器会检查函数的定义，如果找不到定义，就会报错。**


<br>

至此，我们不仅知道 C 工作的原理，还在一定程度上了解 `.h`，`.c` 文件的关系
    

<br>

---

# 编译器是如何工作的

## todo 

<br>

---

# 链接器是如何工作的

## todo

<br>

---

# 基本数据类型

在 C 中，有以下几种基本数据类型：

## 整型

| 类型 | 字节数 | signed | unsigned |
|:-:|:-:|:-:|:-:|
| `short`    | 2      | \(-2^{15}\) 到 \(2^{15} - 1\) `%hd`  | 0 到 \(2^{16} - 1\) `%hu` |
| `int`      | 4      | \(-2^{31}\) 到 \(2^{31} - 1\) `%d`  | 0 到 \(2^{32} - 1\) `%u` |
| `long long`| 8      | \(-2^{63}\) 到 \(2^{63} - 1\) `%lld`  | 0 到 \(2^{64} - 1\) `%llu`|

特别的，为了兼容性，有了精确宽度整数类型（exact-width integers types）的定义。

`#include <stdint.h>`

| 类型 | 字节数 | signed | unsigned |
|:-:|:-:|:-:|:-:|
|`int8_t`|1| \(-2^{7}\) 到 \(2^{7} - 1\) | 0 到 \(2^{8} - 1\) |
|`int16_t`|2| \(-2^{15}\) 到 \(2^{15} - 1\) | 0 到 \(2^{16} - 1\) |
|`int32_t`|4| \(-2^{31}\) 到 \(2^{31} - 1\) | 0 到 \(2^{32} - 1\) |
|`int64_t`|8| \(-2^{63}\) 到 \(2^{63} - 1\) | 0 到 \(2^{64} - 1\) |

特别的，GCC编译器还支持 `__int128_t` 类型，即128位整型。

遗憾的，因为是编译器扩展，所以不是标准的C语言，无法直接 printf。

## 浮点型

| 类型 | 字节数 | 精度 | 格式化 |
|:-:|:-:|:-:|:-:|
| `float`    | 4      | $10^{-7}$ | `%f` |
| `double`   | 8      | $10^{-15}$ | `%lf` |

## 字符型

| 类型 | 字节数 | 格式化 |
|:-:|:-:|:-:|
| `char` | 1 | `%c` |

常用的 ASCII 码表：

| 字符 | ASCII 码 |
|:-:|:-:|
| `\0`| 0 |
| `0` | 48 |
| `A` | 65 |
| `a` | 97 |

## 指针

指针也是一种数据类型，它用于存储内存地址。

| 类型 | 字节数 | 格式化 |
|:-:|:-:|:-:|
| `void *` | 8 | `%p` |

和其他数据类型一样
* `int` 存储数字
* `char` 存储字符
* `double` 存储浮点数
* **`void *` 存储内存地址**

**那为何有 `char *`、`int *`、`double *` 等类型呢？**
**指明指针指向的数据类型：**
1. 指针的算术操作
    不同类型的指针运算时，步长不同。
    * `char` 占用 1 字节， `char *` 步长为 1。
        ```cpp
        char c = '6';   // c 的地址为 0xa
        char *p = c;    // p 的 值 为 0xa
        p = p + 1;      // p 的 值 为 0xb
        ```

    * `int` 占用 4 字节， `int *` 步长为 4。
        ```cpp
        int i = 6;      // i 的地址为 0x1
        int *p = i;     // p 的 值 为 0x1
        p = p + 1;      // p 的 值 为 0x5
        ```

2. 类型安全
    编译器会在编译时检查指针的类型，
    从而避免不同类型的指针直接赋值或比较，
    确保了在程序中正确使用指针。

```c
#include <stdio.h>

int main(){
    char c = '6';
    char t = '?';
    char *p = &c;

    // 变量 c 的值
    // 变量 c 的地址
    // 指针 p 的值
    // 指针 p 的地址
    // 通过指针 p 访问变量 c 的值
	puts("c的地址 和 p的值，都是一样的 | *p 就是 c的值");
    printf("\nc                &c               p                &p               *p\n");
    printf("%-16c %-16p %-16p %-16p %-16c\n\n", c, &c, p, &p, *p);

	puts("c+1的地址 和 p+1的值，都是一样的 | *p+1 就是 t的值");

    printf("\nc                &c+1             p+1              &p+1             *(p+1)\n");
    printf("%-16c %-16p %-16p %-16p %-16c\n\n", c, &c+1, p+1, &p+1, *(p+1));

	puts("输入一个数，到 p+1 的值里面去：");
    scanf("%c", p+1);
	puts("c+1的地址 和 p+1的值，都是一样的 | *p+1 就是 t的值");

    printf("\nc                &c+1             p+1              &p+1             *(p+1)\n");
    printf("%-16c %-16p %-16p %-16p %-16c\n\n", c, &c+1, p+1, &p+1, *(p+1));

	puts("输出t的值：");

    printf("%c", t);
}
```

## 聚合类型

聚合类型是由多个基本类型组成的数据类型。

**数组**

数组的本质是一段连续的内存空间，数组名是数组首元素的地址。

```c
int a[100];         // 定义一个大小为 100 的数组
int b[] = {1,2,3,4};// 定义一个大小为 4 的数组，元素为 1,2,3,4
int c[100] = {1};   // 定义一个大小为 100 的数组，第一个元素为 1，其他元素为 0
```

**结构体**

* 数组：多个 **相同** 元素的集合
* 结构体：多个 **不同** 的元素的集合

```c
struct PII{
	int fst;
	int sed;
};

PII a;              // 定义一个结构体变量
PII b[10];          // 定义一个结构体数组      
```

```c
a.fst = 1;          // 访问结构体变量的成员
scanf("%d", &a.fst);// 输入结构体变量的成员
```

**联合体**



---

# Memory Areas

C 在程序执行时，将内存大致分为 **代码区**，**全局区**，**栈区**，**堆区** 四个区域。
不同的区域存储不同的数据，赋予不同的生命周期，能够更灵活地进行编程。

## Code Segment

代码区，简单来说，就是存放 **执行指令** 的地方。
代码区是只读的，不允许修改。
当一个 `.c` 文件，开始运行时，从 `ROM` 加载到 `RAM`，成为代码区。

## Data Segment

数据区（常量区），用来存储 **静态变量**、**全局变量**、**静态数据**。
在这个区域中，数据的大小和结构在程序编译时就已经确定。

1. **全局变量：** 如果你在程序中定义了一个全局变量，它会被存储在数据段中。例如：
   
   ```c
   int globalVar = 10;
   ```
   
   在这个例子中，`globalVar`是一个全局变量，它的初始值为10，会被存储在数据段中。

2. **静态变量：** 静态变量（包括静态全局变量和静态局部变量）也会被存储在数据段中。例如：

   ```c
   void function() {
       static int staticVar = 5;
   }
   ```
   
   在这个例子中，`staticVar`是一个静态局部变量，它的值在函数调用之间保持不变，存储在数据段中。

3. **常量：** 字符串常量和其他常量数据也被存储在数据段中。例如：

   ```c
   const char hello[] = "Hello, World!";
   ```

   在这个例子中，字符串常量"Hello, World!"会被存储在数据段中，而`hello`数组则会在栈或堆上分配内存，存储在数据段中的地址。

## Stack

## Heap