---
html:
    toc: true   # 打开侧边目录
export_on_save:
    html: true  # 自动保存
---


### 题目：任务调度与数据分配

#### 问题背景：

随着云计算、5G 通信和人工智能中芯片硬件计算能力的快速发展，硬件架构正朝着更加复杂的多核和异构架构演进。任务调度和内存分配的耦合问题广泛存在于操作系统、分布式系统和编译器中，在软硬件协同优化中起着关键作用。在这个问题中，你需要设计一个高效的任务调度算法以及一个内存分配策略。

#### 描述：

有 \( l \) 个任务 \( J_1, J_2, \ldots, J_l \) 需要调度到 \( n \) 台具有不同处理能力的机器 \( M_1, M_2, \ldots, M_n \) 上。同时有 \( m \) 个具有不同传输速度和存储配额的磁盘 \( D_1, D_2, \ldots, D_m \)。

- 机器 \( M_i \) 的处理能力为 \( \text{power}(M_i) \)。
- 磁盘 \( D_j \) 的读写传输速率为 \( \text{rate}(D_j) \)，存储配额为 \( \text{quota}(D_j) \)。
- 每个任务 \( J_i \) 的大小为 \( \text{size}(J_i) \)，如果在机器 \( M_j \) 上运行，将花费 \( \text{size}(J_i) / \text{power}(M_j) \) 的时间。
- 当一个任务 \( J_i \) 完成执行后，它将输出一个大小为 \( \text{data}(J_i) \) 的数据到某个磁盘。这将花费 \( \text{output}(J_i) / \text{rate}(D_k) \) 的额外时间。
- 在任务 \( J_i \) 开始执行之前，它需要读取其他一些任务的输出数据。我们用 \( \text{PREDdata}(J_i) \) 表示 \( J_i \) 需要的前置任务集合。读取这些数据所需的总时间为 \( \sum_{J_j \in \text{PREDdata}(J_i)} \text{output}(J_j) / \text{rate}(D_{z_j}) \)。

你的目标是找到一个任务调度方案，即将任务分配给机器和磁盘。更具体地，对于每个任务 \( J_i \)，你需要指定三个参数 \( (x_i, y_i, z_i) \)，即 \( J_i \) 在时间 \( x_i \) 开始在机器 \( M_{y_i} \) 上运行，并将其数据存储到磁盘 \( D_{z_i} \) 上。最早的任务开始时间为 0。

当一个任务开始时，它会经历三个阶段：从磁盘读取数据、执行任务和将其数据写入磁盘。我们用 \( a_i, b_i, c_i \) 表示这三个阶段的开始时间，用 \( d_i \) 表示最后一个阶段的结束时间。这些值按以下方式确定：

- \( a_i = x_i \)
- \( b_i = a_i + \sum_{J_j \in \text{PREDdata}(J_i)} \text{output}(J_j) / \text{rate}(D_{z_j}) \)
- \( c_i = b_i + \text{size}(J_i) / \text{power}(M_{y_i}) \)
- \( d_i = c_i + \text{output}(J_i) / \text{rate}(D_{z_i}) \)

所有上述的除法结果都需要向上取整。此外，一个可行的调度应该满足以下要求：

1. 环境依赖性：如果任务 \( J_i \) 环境依赖于任务 \( J_j \)，则 \( J_i \) 不能在 \( J_j \) 完成执行之前开始，即 \( a_i \geq c_j \)。注意，如果 \( J_i \) 和 \( J_j \) 安排在同一台机器上，则仍需等待 \( J_j \) 完成存储数据。
2. 数据依赖性：如果 \( J_j \) 属于 \( \text{PREDdata}(J_i) \)，则 \( J_i \) 不能在 \( J_j \) 完成数据存储之前开始，即 \( a_i \geq d_i \)。
3. 机器亲和性：每个任务 \( J_i \) 有一个亲和机器列表 \( A_i \)，任务必须被调度到其亲和机器之一，即 \( y_i \in A_i \)。
4. 不可中断性：每台机器在其生命周期内只能执行一个任务或传输一个数据，且不能中断。换句话说，对于每对任务 \( J_i \) 和 \( J_j \)，如果 \( y_i = y_j \)，则两个区间 \([a_i, d_i]\) 和 \([a_j, d_j]\) 不能有任何重叠。
5. 磁盘配额：存储在同一磁盘上的所有数据的总大小不能超过该磁盘的配额，即 \( \sum_{J_i:z_i=j} \text{data}(J_i) \leq \text{quota}(D_j) \)，对所有 \( 1 \leq j \leq m \) 均需满足。

#### 目标：

你的目标是找到一个最小化总工期（最后一个任务的完成时间）的分配方案，即最小化 \( \max_{1 \leq i \leq l} d_i \)。

#### 输入：

第一行包含一个整数 \( l \)，表示任务的数量。在接下来的 \( l \) 行中，每行表示一个任务：前三个整数表示任务编号、任务大小和任务输出数据大小。第四个整数 \( k \) 表示该任务的亲和机器数量，剩下的 \( k \) 个整数是亲和机器的编号。

接下来一行包含一个整数 \( n \)，表示机器的数量。在接下来的 \( n \) 行中，每行包含两个整数，表示机器编号和其处理能力。

再接下来一行包含一个整数 \( m \)，表示磁盘的数量。在接下来的 \( m \) 行中，每行包含三个整数，表示磁盘编号、其速率和配额。

最后部分描述了任务之间的两种依赖关系。第一行是一个整数 \( N \)，表示数据依赖的数量。在接下来的 \( N \) 行中，每行包含两个整数 \( i, j \)，表示任务 \( j \) 数据依赖于任务 \( i \)。

然后是一行整数 \( M \)，表示环境依赖的数量。在接下来的 \( M \) 行中，每行包含两个整数 \( i, j \)，表示任务 \( j \) 环境依赖于任务 \( i \)。

#### 输出：

你应该输出 \( l \) 行，每行 \( i \) 包含四个整数 \( i, x, y, z \)，表示任务 \( J_i \) 将在时间 \( x \) 开始在机器 \( M_y \) 上运行，并将结果存储在磁盘 \( D_z \) 上。

#### 示例：

输入：
```
6
1 40 6 2 1 2
2 20 6 2 1 2
3 96 10 2 1 2
4 20 6 2 1 2
5 60 0 2 1 2
6 20 0 1 1
2
1 1
2 2
2
1 1 30
2 2 17
8
1 2
1 4
2 4
2 5
3 5
3 6
4 6
1
1 5
```

输出：
```
1 0 2 2
2 23 1 1
3 23 2 2
4 52 1 1
5 79 2 1
6 87 1 2
```