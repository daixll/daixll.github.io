---
html:
    toc: true   # 打开侧边目录
export_on_save:
    html: true  # 自动保存
---

# 密码学

## 密码算法

密码算法是一种数学算法，它将明文转换为密文，或将密文转换为明文。

* **加密**： 明文 -> 密文
* **解密**： 密文 -> 明文
* **密钥**： 加密和解密的算法参数

## 对称加密

加密和解密使用的是同一个密钥，称为 **对称加密**。

* **加密**： 明文 + 密钥A -> 密文
* **解密**： 密文 + 密钥A -> 明文


### 序列密码

密钥和明文一一对应，称为 **序列密码**。意味着密钥和明文的长度是一样的。

> 简单理解，我们约定
> * 密钥 `1415926`
> * 明文 `1234567`
>
> 加密后
> 
> * 密文 `2649483` 明文和密钥的每位相加且%10
> 
> 解密后
> * 明文 `1234567` 密文和密钥的每位相减且%10

缺点：
* 密文重复，容易破解
* 明文、密文、密钥长度一样，不适合长文本

### 分组密码

将明文分成若干长度为 `L` 的组，使用 `L` 长度的密钥，对每组进行加密，称为 **分组密码**。


<br>

---

# 实验

## DES 

* DES算法属于 **对称密码** 算法中的 **分组密码** 算法，每组长度为 `64 bit`。
* DES算法的密钥长度为 `64 bit`，但是由于每隔 `7 bit` 会插入一个奇偶校验位，因此实际密钥长度为 `56 bit`。

**加密** 流程：

1. 对明文 **$plaintext$** 分组，得到 **$m_i$**
1. 对明文 **$m_i$** 初始置换，得到 **$m_i'$**，`IP`
1. 对密钥 **$privatekey$** 奇偶校验，得到 **$privatekey'$**
1. 根据 **$privatekey'$** 开始生成 16 个子密钥 **$k_i$**，`PC1` `LEFT` `PC2`
1. 16 轮迭代（Feistel），`E` `S` `P`
1. 逆初始置换，`rIP`

### 【1】 明文分组

将明文 **$plaintext$** 分成若干长度为 `64 bit` 的组，以使用 `64 bit` 长度的密钥。

> 在 `MSVC（x64） utf-8` 中
> 字符一般是 `1 byte`，也就是 `8 bit`，汉字占用 `3-4 byte`。

最后一组不足64位的，每一位补 `0`（注意！不是字符 `0`）。

### 【2】 初始置换

将明文分组 **$m_i$** 进行初始置换，置换后的结果作为加密的输入。

```cpp
const int IP[65] = { 0,
58,50,42,34,26,18,10,2,
60,52,44,36,28,20,12,4,
62,54,46,38,30,22,14,6,
64,56,48,40,32,24,16,8,
57,49,41,33,25,17,9,1,
59,51,43,35,27,19,11,3,
61,53,45,37,29,21,13,5,
63,55,47,39,31,23,15,7 };
```

> 将 `明文分组` 中的第 `58` 位的值作为第 `1` 位的值，第 `50` 位的值作为第 `2` 位的值，以此类推。
> 将 `明文分组` 中的 `IP[j]` 位，作为 `j` 位，即 `m[ IP[j] ]` 作为 `m[ j ]`。

```cpp
auto mm = m[i];
for (int j = 1; j <= 64; ++j)
    m[i][j] = mm[IP[j]];
```

### 【3】 密钥奇偶校验

对于传入的密钥 **$privatekey$**：

* 不足 `7 byte` 的，补字符 `0`
* 超过 `7 byte` 的，截断

此时，我们拥有一个长度为 `56 bit` 的密钥 **$privatekey$**：
**$$B_1 \ B_2 \ B_3 \ ... \ B_{56}$$**

对于每 `7 bit`，我们计算其奇偶校验位，得到一个长度为 `64 bit` 的密钥 **$privatekey'$**：


**$$B_1 \ B_2 \ ... \ B_{7} \ P_1 $$**

**$$B_8 \ B_9 \ ... \ B_{14} \ P_2 $$**

**$$...$$**

**$$B_{50} \ B_{51} \ ... \ B_{56} \ P_8 $$**

> $B_1 - B_7$ 的 `1` 的个数为奇数，$P_1 = 1$，否则 $P_1 = 0$。

### 【4】 生成16个子密钥

对密钥 **$privatekey'$** 进行置换，得到置换后的 **$privatekey'$**：

```cpp
const int PC1[57] = { 0,
57,49,41,33,25,17,9,
1,58,50,42,34,26,18,
10,2,59,51,43,35,27,
19,11,3,60,52,44,36,
63,55,47,39,31,23,15,
7,62,54,46,38,30,22,
14,6,61,53,45,37,29,
21,13,5,28,20,12,4 };
```

> 将 `密钥奇偶校验` 中的第 `57` 位的值作为第 `1` 位的值，第 `49` 位的值作为第 `2` 位的值，以此类推。
> 将 `密钥奇偶校验` 中的 `PC1[i]` 位，作为 `i` 位，即 `privatekey[ PC1[i] ]` 作为 `privatekey[ i ]`。

```cpp
auto pp = " ";
for (int i = 1; i <= 56; ++i)
    pp += privatekey[PC1[i]];
privatekey = pp;
```

经过置换后，将其分成两部分，每部分 `28 bit`，分别称为 **$C_0$** 和 **$D_0$**。

> 后面 16 轮，需要对 **$C_i$** 和 **$D_i$** 进行 **循环左移** 操作，左移的位数由 `LEFT` 数组决定。

```cpp
const int LEFT[17]{ 0,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 };
```

####  i 轮置换

将 **$C_{i-1}$** 和 **$D_{i-1}$** 左移 `LEFT[i]` 位，得到 **$C_i$** 和 **$D_i$**。

将 **$C_i$** 和 **$D_i$** 合并成 **$K_i$**，进行置换：

```cpp
const int PC2[49] = { 0,
14,17,11,24,1,5,
3,28,15,6,21,10,
23,19,12,4,26,8,
16,7,27,20,13,2,
41,52,31,37,47,55,
30,40,51,45,33,48,
44,49,39,56,34,53,
46,42,50,36,29,32 };
```

> 将 **$K_i$** 的第 `14` 位的值作为第 `1` 位的值，第`17` 位的值作为第 `2` 位的值，以此类推。
> 将 **$K_i$** 的 `PC2[j]` 位，作为 `j` 位，即 `K_i[ PC2[j] ]` 作为 `K_i[ j ]`。

```cpp
auto kk = K[i];
for (int j = 1; j <= 48; ++j)
    K[i][j] = kk[PC2[j]];
```

置换后的 **$K_i$**，即第 `i` 轮的子密钥。

### 【5】 迭代（Feistel）

将初始置换后的明文 **$m_i$** 分成两部分，每部分 `32 bit`，分别称为 **$L_0$** 和 **$R_0$**。

#### i 轮迭代

将 $R_{i-1}$ 扩展成 `48 bit`：

```cpp
const int E[49]{ 0,
32,1,2,3,4,5,
4,5,6,7,8,9,
8,9,10,11,12,13,
12,13,14,15,16,17,
16,17,18,19,20,21,
20,21,22,23,24,25,
24,25,26,27,28,29,
28,29,30,31,32,1 };
```

> 将 $R_{i-1}$ 的第 `32` 位的值作为第 `1` 位的值，第 `1` 位的值作为第 `2` 位的值，以此类推。
> 将 $R_{i-1}$ 的 `E[j]` 位，作为 `j` 位，即 `R[i-1][ E[j] ]` 作为 `R[i-1][ j ]`。

```cpp
R[i] = " ";
for (int j = 1; j <= 48; ++j) 
    R[i] += R[i - 1][E[j]];
```

将 **$R_i$** 和 **$K_i$** 进行异或操作，得到 `48 bit` 的结果 **$R_i$** ，将其分成 `8` 组，每组 `6位`。

对于每一组（`6位`）：

* 将 **首位和末位** 作为 **行号**，**中间4位** 作为列号，查 $S_i$ 表得到 `4位` 的结果。
> 例如，`101111`
> * 首位和末位为 `11`，十进制为 `3`
> * 中间4位为 `0111`，十进制为 `7`
> * 查表得到 `S[3][7]` 的值为 `1010`

* 将结果转换成二进制，得到 `4 bit` 的结果。

将 `8` 组 `4 bit` 的结果合并，得到 `32 bit` 的结果 **$R_i$** ，进行置换：

```cpp
const int P[33] = { 0,
16,7,20,21,29,12,28,17,
1,15,23,26,5,18,31,10,
2,8,24,14,32,27,3,9,
19,13,30,6,22,11,4,25 };
```

> 将 **$R_i$** 的第 `16` 位的值作为第 `1` 位的值，第 `7` 位的值作为第 `2` 位的值，以此类推。
> 将 **$R_i$** 的 `P[j]` 位，作为 `j` 位，即 `R_i[ P[j] ]` 作为 `R_i[ j ]`。

```cpp
auto rr = R[i];
for(int j=1; j<=32; ++j)
    R[i][j] = rr[P[j]];
R[i] = rr;
```

**$R_i$** = **$R_i \oplus L_{i-1}$**
**$L_i$** = **$R_{i-1}$**

### 【6】 逆初始置换

将 **$L_{16}$** 和 **$R_{16}$** 合并，得到 `64 bit` 的 **$ciphertext$**，
进行逆初始置换，得到密文 **$ciphertext$**。

```cpp
const int rIP[65] = { 0,
40,8,48,16,56,24,64,32,
39,7,47,15,55,23,63,31,
38,6,46,14,54,22,62,30,
37,5,45,13,53,21,61,29,
36,4,44,12,52,20,60,28,
35,3,43,11,51,19,59,27,
34,2,42,10,50,18,58,26,
33,1,41,9,49,17,57,25 };
```

> 将 `密文` 中的第 `40` 位的值作为第 `1` 位的值，第 `8` 位的值作为第 `2` 位的值，以此类推。
> 将 `密文` 中的 `rIP[j]` 位，作为 `j` 位，即 `ciphertext[ rIP[j] ]` 作为 `ciphertext[ j ]`。

```cpp
auto cc = ciphertext;
for (int j = 1; j <= 64; ++j)
    ciphertext[j] = cc[rIP[j]];
```
