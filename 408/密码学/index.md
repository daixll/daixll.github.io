---
html:
    toc: true   # 打开侧边目录
export_on_save:
    html: true  # 自动保存
---

# openssl

**openssl** 是一个开源的软件库包，实现了 **SSL** 和 **TLS** 协议，包含了众多密码算法，常用于 **HTTPS** 的服务器端和客户端的实现。

## openssl 命令

[官方手册](https://www.feistyduck.com/library/openssl-cookbook/online/)

## ssllib

[官方手册 3.0](https://www.openssl.org/docs/man3.0/man7/)
[加密部分](https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_encrypt.html)


**安装**

* `ubuntu`
    ```bash
    sudo apt install libssl-dev
    ```
**编译**

* `g++`
    ```bash
    g++ main.cpp -lssl -lcrypto
    ```



<br>

---

# 密码学

## 密码算法

密码算法是一种数学算法，它将明文转换为密文，或将密文转换为明文。

* **加密**： 明文 -> 密文
* **解密**： 密文 -> 明文
* **密钥**： 加密和解密的算法参数

## 对称加密

加密和解密使用的是同一个密钥，称为 **对称加密**。

* **加密**： 明文 + 密钥A -> 密文
* **解密**： 密文 + 密钥A -> 明文


### 序列密码

密钥和明文一一对应，称为 **序列密码**。意味着密钥和明文的长度是一样的。

> 简单理解，我们约定
> * 密钥 `1415926`
> * 明文 `1234567`
>
> 加密后
> 
> * 密文 `2649483` 明文和密钥的每位相加且%10
> 
> 解密后
> * 明文 `1234567` 密文和密钥的每位相减且%10

缺点：
* 密文重复，容易破解
* 明文、密文、密钥长度一样，不适合长文本

### 分组密码

将明文分成若干长度为 `L` 的组，使用 `L` 长度的密钥，对每组进行加密，称为 **分组密码**。


<br>

---

# 题

## 信息安全的目标有哪些？

1. 机密性（Confidentiality）：保证信息不被非法获取。
2. 完整性（Integrity）：保证信息不被非法修改。
3. 认证性（Authentication）：保证信息的发送者和接收者的身份正确。
4. 不可否认性（Non-repudiation）：保证信息的发送者不能否认发送、接收过信息。
5. 可用性（Availability）：保证信息不被非法拒绝。
6. 可控性（Controllability）：保证信息的发送者和接收者可以控制信息的传输过程。
7. 匿名性（Anonymity）：保证信息的发送者和接收者的身份不被泄露。
8. 隐私性（Privacy）：保证信息的发送者和接收者的隐私不被泄露。
9. 可靠性（Reliability）：保证信息的发送者和接收者的信息传输过程可靠。

## 密码体制安全性有几种？

1. 计算安全（Computational Security）：攻击者无法在有限时间内破解密码。
2. 无条件安全（Unconditional Security）：攻击者无法破解（无限时间无限计算力的情况下）密码。
3. 可证明安全（Provable Security）：密码体制的安全性可以被证明。

## 单表代换和多表代换的区别？

* 单表代换密码：

    1. 密文与明文一一对应，每个字母逐个进行代换。
    2. 密钥空间较小，易于破解。
    3. 密文长度足够长时，可以使用词频分析进行破解。
    4. 代表性的单表代换密码有凯撒密码、移位密码、简单替换密码等。

* 多表代换密码：

    1. 密文与明文不是一一对应，多个字母同时进行代换。
    2. 密钥空间较大，破解难度较大。
    3. 密文长度足够长时，可以使用统计分析进行破解。
    4. 代表性的多表代换密码有Playfair密码、Vigenere密码、Hill密码等。

## Hill加密的抗选择明文攻击（CPA）的强度是多少？


**密钥矩阵的秩**

密钥矩阵的秩表示密钥矩阵中线性无关列的个数。如果密钥矩阵的秩为 $n$，则密钥矩阵可以表示为 $n$ 个线性无关列向量的线性组合。

在 Hill 加密中，密文 $C$ 可以表示为：

$$C = K * M$$


其中，$K$ 是密钥矩阵，$M$ 是明文。

如果密钥矩阵的秩为 $n$，则 $C$ 可以表示为 $n$ 个线性无关列向量的线性组合。这意味着，攻击者无法通过密文 $C$ 来唯一确定明文 $M$。因此，Hill 加密是完全安全的。

如果密钥矩阵的秩小于 $n$，则 $C$ 可以表示为 $n - r$ 个线性无关列向量的线性组合和 $r$ 个线性相关列向量的线性组合。这意味着，攻击者可以通过密文 $C$ 来推测明文 $M$ 中 $n - r$ 个字符的值。

例如，如果密钥矩阵的秩为 $n - 1$，则攻击者可以通过密文 $C$ 来推测明文 $M$ 中 $n - 1$ 个字符的值。剩下的一个字符的值可以通过密钥矩阵和其他已知的字符来推测。

**密钥矩阵的范数**

密钥矩阵的范数表示密钥矩阵的大小。密钥矩阵的范数越大，密钥矩阵越难被攻击者破解。

在 Hill 加密中，密钥矩阵的范数可以通过以下公式来计算：

$$|K|^2 = \sum_{i,j = 1}^n |K_{ij}|^2$$

其中，$K_{ij}$ 是密钥矩阵 $K$ 的第 $i$ 行第 $j$ 列的元素。

一般来说，密钥矩阵的范数越大，攻击者破解密钥的难度越大。

**结论**

综上所述，Hill 加密的抗 CPA 强度取决于密钥矩阵的秩和范数。如果密钥矩阵的秩为 $n$，则 Hill 加密是完全安全的。如果密钥矩阵的秩小于 $n$，则 Hill 加密的安全性取决于密钥矩阵的秩。密钥矩阵的秩越小，攻击者破解密钥的难度越小。

在实际应用中，Hill 加密的密钥矩阵通常是随机生成的。因此，其抗 CPA 强度通常是比较高的。


## 4级LFSR的特征多项式为 $f(x)=1+x^2+x^4$，初始态为 $(0,0,1,1)$。求输出序列及其周期。


## 4级LFSR的特征多项式为 $f(x)=1+x^3+x^4$，初始态为 $(0,0,1,1)$。求输出序列及其周期。

## 4级LFSR的特征多项式为 $f(x)=1+x+x^4$，初始态为 $(0,0,1,1)$。求输出序列及其周期。

## 求一个4级LFSR的特征多项式 $f(x)$，其初始态为 $(0,0,1,1)$，使得输出序列的周期为最大值 $15$。

4级LFSR的特征多项式 $f(x)$ 的形式为 $1+x+x^2+x^3+x^4$。根据初始态 $(0,0,1,1)$，我们可以得到以下状态转移表：

n | a_n | a_{n+1}
---|---|---|
0 | 0 | 0
1 | 0 | 1
2 | 1 | 1
3 | 1 | 0
4 | 1 | 1
5 | 1 | 0
6 | 0 | 1
7 | 1 | 1
8 | 1 | 0
9 | 0 | 1
10 | 1 | 1
11 | 1 | 0
12 | 0 | 1
13 | 1 | 1
14 | 1 | 0
15 | 0 | 1

从表中可以看出，输出序列的周期为 $15$。因此，4级LFSR的特征多项式 $f(x)$ 可以取值为 $1+x+x^2+x^3+x^4$。

另一种方法是，根据输出序列的周期为 $15$，可以列出以下方程：

$$(1+x+x^2+x^3+x^4)^{15} = 1$$

解得该方程，可以得到 $f(x) = 1+x+x^2+x^3+x^4$。

## 设计一个以 LSFR 为基础的算法，以自己的名字命名。算法中有两个 $LS-FR$，特征分别是 $f(x)=1+x^4+x^5, f(x)=1+x^3$，钟控抽头为寄存器的中间比特，钟控函数是 $g(x,y) = x*y$，初始密钥是 $11001||110$。输出前 $30bit$，加密自己的名字。

我的名字是戴兴龙，对应的 ASCII 码是 `1000100 1100001 1101001 1110100 1111000 1101111 1101110 1100111`，转换成二进制是 `01100100 01100001 01101001 01110100 01111000 01101111 01101110 01100111`，长度为 `64 bit`。

1. 选择两个 LFSR 和初始化：
   - LFSR1 特征多项式：\(f_1(x) = 1 + x^4 + x^5\)
   - LFSR2 特征多项式：\(f_2(x) = 1 + x^3\)
   - 初始密钥：\(11001||110\)

2. 钟控抽头和钟控函数设计：
   - 钟控抽头位于 LFSR 寄存器的中间比特。
   - 钟控函数：\(g(x, y) = x \cdot y\)

3. 加密过程设计：
   - 每轮加密包括以下步骤：
      1. 从每个 LFSR 中取出钟控抽头对应的比特。
      2. 计算钟控函数 \(g(x, y) = x \cdot y\) 得到反馈比特。
      3. 对每个 LFSR 进行位移操作和更新，根据特性多项式和计算得到的反馈比特。
      4. 异或操作获得加密比特，将其追加到密文中。

4. 确定加密轮数：
   - 确定算法的轮数，这里设定为 30 轮。

1. LFSR1 和 LFSR2 初始化：
   - LFSR1 初始状态为 \(11001\)，根据 \(f_1(x) = 1 + x^4 + x^5\) 进行初始化。
   - LFSR2 初始状态为 \(110\)，根据 \(f_2(x) = 1 + x^3\) 进行初始化。

2. 加密过程（每轮）：
   - 对于每轮加密，执行以下步骤：
      1. 从 LFSR1 和 LFSR2 中取出钟控抽头对应的比特。
      2. 计算钟控函数 \(g(x, y) = x \cdot y\) 得到反馈比特。
      3. 对 LFSR1 和 LFSR2 进行位移和更新，根据特性多项式和计算得到的反馈比特。
      4. 异或操作获得加密比特，将其追加到密文中。

3. 生成加密序列：
   - 重复步骤 2，直到达到设定的加密轮数（这里是 30 轮）。

4. 输出前30位：
   - 返回生成的加密序列的前 30 位。
    ```python
    LFSR1 = InitializeLFSR("11001", "1 + x^4 + x^5")
    LFSR2 = InitializeLFSR("110", "1 + x^3")
    ciphertext = ""

    for round in range(30):
        clock1 = LFSR1.middle_bit()
        clock2 = LFSR2.middle_bit()

        feedback1 = LFSR1.output() * clock1
        feedback2 = LFSR2.output() * clock2

        LFSR1.shift_left()
        LFSR2.shift_left()

        LFSR1.set_bit(0, feedback1)
        LFSR2.set_bit(0, feedback2)

        cipher_bit = LFSR1.output() XOR LFSR2.output()
        ciphertext += cipher_bit

    print("Ciphertext:", ciphertext[:30])
    ```


# 实验

## DES 

* DES算法属于 **对称密码** 算法中的 **分组密码** 算法，每组长度为 `64 bit`。
* DES算法的密钥长度为 `64 bit`，但是由于每隔 `7 bit` 会插入一个奇偶校验位，因此实际密钥长度为 `56 bit`。

**加密** 流程：

1. 对明文 **$plaintext$** 分组，得到 **$m_i$**
1. 对明文 **$m_i$** 初始置换，得到 **$m_i'$**，`IP`
1. 对密钥 **$privatekey$** 奇偶校验，得到 **$privatekey'$**
1. 根据 **$privatekey'$** 开始生成 16 个子密钥 **$k_i$**，`PC1` `LEFT` `PC2`
1. 16 轮迭代（Feistel），`E` `S` `P`
1. 逆初始置换，`rIP`

### 【1】 明文分组

将明文 **$plaintext$** 分成若干长度为 `64 bit` 的组，以使用 `64 bit` 长度的密钥。

> 在 `MSVC（x64） utf-8` 中
> 字符一般是 `1 byte`，也就是 `8 bit`，汉字占用 `3-4 byte`。

最后一组不足64位的，每一位补 `0`（注意！不是字符 `0`）。

### 【2】 初始置换

将明文分组 **$m_i$** 进行初始置换，置换后的结果作为加密的输入。

```cpp
const int IP[65] = { 0,
58,50,42,34,26,18,10,2,
60,52,44,36,28,20,12,4,
62,54,46,38,30,22,14,6,
64,56,48,40,32,24,16,8,
57,49,41,33,25,17,9,1,
59,51,43,35,27,19,11,3,
61,53,45,37,29,21,13,5,
63,55,47,39,31,23,15,7 };
```

> 将 `明文分组` 中的第 `58` 位的值作为第 `1` 位的值，第 `50` 位的值作为第 `2` 位的值，以此类推。
> 将 `明文分组` 中的 `IP[j]` 位，作为 `j` 位，即 `m[ IP[j] ]` 作为 `m[ j ]`。

```cpp
auto mm = m[i];
for (int j = 1; j <= 64; ++j)
    m[i][j] = mm[IP[j]];
```

### 【3】 密钥奇偶校验

对于传入的密钥 **$privatekey$**：

* 不足 `7 byte` 的，补字符 `0`
* 超过 `7 byte` 的，截断

此时，我们拥有一个长度为 `56 bit` 的密钥 **$privatekey$**：
**$$B_1 \ B_2 \ B_3 \ ... \ B_{56}$$**

对于每 `7 bit`，我们计算其奇偶校验位，得到一个长度为 `64 bit` 的密钥 **$privatekey'$**：


**$$B_1 \ B_2 \ ... \ B_{7} \ P_1 $$**

**$$B_8 \ B_9 \ ... \ B_{14} \ P_2 $$**

**$$...$$**

**$$B_{50} \ B_{51} \ ... \ B_{56} \ P_8 $$**

> $B_1 - B_7$ 的 `1` 的个数为奇数，$P_1 = 1$，否则 $P_1 = 0$。

### 【4】 生成16个子密钥

对密钥 **$privatekey'$** 进行置换，得到置换后的 **$privatekey'$**：

```cpp
const int PC1[57] = { 0,
57,49,41,33,25,17,9,
1,58,50,42,34,26,18,
10,2,59,51,43,35,27,
19,11,3,60,52,44,36,
63,55,47,39,31,23,15,
7,62,54,46,38,30,22,
14,6,61,53,45,37,29,
21,13,5,28,20,12,4 };
```

> 将 `密钥奇偶校验` 中的第 `57` 位的值作为第 `1` 位的值，第 `49` 位的值作为第 `2` 位的值，以此类推。
> 将 `密钥奇偶校验` 中的 `PC1[i]` 位，作为 `i` 位，即 `privatekey[ PC1[i] ]` 作为 `privatekey[ i ]`。

```cpp
auto pp = " ";
for (int i = 1; i <= 56; ++i)
    pp += privatekey[PC1[i]];
privatekey = pp;
```

经过置换后，将其分成两部分，每部分 `28 bit`，分别称为 **$C_0$** 和 **$D_0$**。

> 后面 16 轮，需要对 **$C_i$** 和 **$D_i$** 进行 **循环左移** 操作，左移的位数由 `LEFT` 数组决定。

```cpp
const int LEFT[17]{ 0,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 };
```

####  i 轮置换

将 **$C_{i-1}$** 和 **$D_{i-1}$** 左移 `LEFT[i]` 位，得到 **$C_i$** 和 **$D_i$**。

将 **$C_i$** 和 **$D_i$** 合并成 **$K_i$**，进行置换：

```cpp
const int PC2[49] = { 0,
14,17,11,24,1,5,
3,28,15,6,21,10,
23,19,12,4,26,8,
16,7,27,20,13,2,
41,52,31,37,47,55,
30,40,51,45,33,48,
44,49,39,56,34,53,
46,42,50,36,29,32 };
```

> 将 **$K_i$** 的第 `14` 位的值作为第 `1` 位的值，第`17` 位的值作为第 `2` 位的值，以此类推。
> 将 **$K_i$** 的 `PC2[j]` 位，作为 `j` 位，即 `K_i[ PC2[j] ]` 作为 `K_i[ j ]`。

```cpp
auto kk = K[i];
for (int j = 1; j <= 48; ++j)
    K[i][j] = kk[PC2[j]];
```

置换后的 **$K_i$**，即第 `i` 轮的子密钥。

### 【5】 迭代（Feistel）

将初始置换后的明文 **$m_i$** 分成两部分，每部分 `32 bit`，分别称为 **$L_0$** 和 **$R_0$**。

#### i 轮迭代

将 $R_{i-1}$ 扩展成 `48 bit`：

```cpp
const int E[49]{ 0,
32,1,2,3,4,5,
4,5,6,7,8,9,
8,9,10,11,12,13,
12,13,14,15,16,17,
16,17,18,19,20,21,
20,21,22,23,24,25,
24,25,26,27,28,29,
28,29,30,31,32,1 };
```

> 将 $R_{i-1}$ 的第 `32` 位的值作为第 `1` 位的值，第 `1` 位的值作为第 `2` 位的值，以此类推。
> 将 $R_{i-1}$ 的 `E[j]` 位，作为 `j` 位，即 `R[i-1][ E[j] ]` 作为 `R[i-1][ j ]`。

```cpp
R[i] = " ";
for (int j = 1; j <= 48; ++j) 
    R[i] += R[i - 1][E[j]];
```

将 **$R_i$** 和 **$K_i$** 进行异或操作，得到 `48 bit` 的结果 **$R_i$** ，将其分成 `8` 组，每组 `6位`。

对于每一组（`6位`）：

* 将 **首位和末位** 作为 **行号**，**中间4位** 作为列号，查 $S_i$ 表得到 `4位` 的结果。
> 例如，`101111`
> * 首位和末位为 `11`，十进制为 `3`
> * 中间4位为 `0111`，十进制为 `7`
> * 查表得到 `S[3][7]` 的值为 `1010`

* 将结果转换成二进制，得到 `4 bit` 的结果。

将 `8` 组 `4 bit` 的结果合并，得到 `32 bit` 的结果 **$R_i$** ，进行置换：

```cpp
const int P[33] = { 0,
16,7,20,21,29,12,28,17,
1,15,23,26,5,18,31,10,
2,8,24,14,32,27,3,9,
19,13,30,6,22,11,4,25 };
```

> 将 **$R_i$** 的第 `16` 位的值作为第 `1` 位的值，第 `7` 位的值作为第 `2` 位的值，以此类推。
> 将 **$R_i$** 的 `P[j]` 位，作为 `j` 位，即 `R_i[ P[j] ]` 作为 `R_i[ j ]`。

```cpp
auto rr = R[i];
for(int j=1; j<=32; ++j)
    R[i][j] = rr[P[j]];
R[i] = rr;
```

**$R_i$** = **$R_i \oplus L_{i-1}$**
**$L_i$** = **$R_{i-1}$**

### 【6】 逆初始置换

将 **$L_{16}$** 和 **$R_{16}$** 合并，得到 `64 bit` 的 **$ciphertext$**，
进行逆初始置换，得到密文 **$ciphertext$**。

```cpp
const int rIP[65] = { 0,
40,8,48,16,56,24,64,32,
39,7,47,15,55,23,63,31,
38,6,46,14,54,22,62,30,
37,5,45,13,53,21,61,29,
36,4,44,12,52,20,60,28,
35,3,43,11,51,19,59,27,
34,2,42,10,50,18,58,26,
33,1,41,9,49,17,57,25 };
```

> 将 `密文` 中的第 `40` 位的值作为第 `1` 位的值，第 `8` 位的值作为第 `2` 位的值，以此类推。
> 将 `密文` 中的 `rIP[j]` 位，作为 `j` 位，即 `ciphertext[ rIP[j] ]` 作为 `ciphertext[ j ]`。

```cpp
auto cc = ciphertext;
for (int j = 1; j <= 64; ++j)
    ciphertext[j] = cc[rIP[j]];
```
