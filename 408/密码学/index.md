---
html:
    toc: true   # 打开侧边目录
export_on_save:
    html: true  # 自动保存
---

# 密码学

## 密码算法

密码算法是一种数学算法，它将明文转换为密文，或将密文转换为明文。

* **加密**： 明文 -> 密文
* **解密**： 密文 -> 明文
* **密钥**： 加密和解密的算法参数

## 对称加密

加密和解密使用的是同一个密钥，称为 **对称加密**。

* **加密**： 明文 + 密钥A -> 密文
* **解密**： 密文 + 密钥A -> 明文


### 序列密码

密钥和明文一一对应，称为 **序列密码**。意味着密钥和明文的长度是一样的。

> 简单理解，我们约定
> * 密钥 `1415926`
> * 明文 `1234567`
>
> 加密后
> 
> * 密文 `2649483` 明文和密钥的每位相加且%10
> 
> 解密后
> * 明文 `1234567` 密文和密钥的每位相减且%10

缺点：
* 密文重复，容易破解
* 明文、密文、密钥长度一样，不适合长文本

### 分组密码

将明文分成若干长度为 `L` 的组，使用 `L` 长度的密钥，对每组进行加密，称为 **分组密码**。


<br>

---

# 实验

## DES 

* DES算法属于 **对称密码** 算法中的 **分组密码** 算法
* DES算法的密钥长度为64位，但是由于每隔7位会插入一个奇偶校验位，因此实际密钥长度为56位

其加密流程如下：

1. 明文分组（64位）
2. 初始置换
3. 生成16个子密钥
4. 16轮迭代（Feistel）
5. 逆初始置换

### 明文分组

将明文分成若干长度为 `64位` 的组，使用 `64位` 长度的密钥。

> 在 `MSVC（x64） utf-8` 中
> 字符一般是 1 个字节，也就是 8 位，汉字占用3或4个字节。

最后一组不足64位的，每一位补 `0`（注意！不是字符 `0`）。

### 初始置换

将明文分组进行初始置换，置换后的结果作为加密的输入。

```cpp
const int IP[65] = { 0,
58,50,42,34,26,18,10,2,
60,52,44,36,28,20,12,4,
62,54,46,38,30,22,14,6,
64,56,48,40,32,24,16,8,
57,49,41,33,25,17,9,1,
59,51,43,35,27,19,11,3,
61,53,45,37,29,21,13,5,
63,55,47,39,31,23,15,7 };
```

> 将 `明文分组` 中的 `58` 位的值作为第一位，`50` 位的值作为第二位，以此类推。


### 生成16个子密钥

选择一个你喜欢的 `64位` 的密钥，将其进行置换：

```cpp
const int PC1[57] = { 0,
57,49,41,33,25,17,9,
1,58,50,42,34,26,18,
10,2,59,51,43,35,27,
19,11,3,60,52,44,36,
63,55,47,39,31,23,15,
7,62,54,46,38,30,22,
14,6,61,53,45,37,29,
21,13,5,28,20,12,4 };
```

经过置换后，将其分成两部分，每部分 `28位`，分别称为 `C0` 和 `D0`。

后面每一轮，需要对 `C0` 和 `D0` 进行左移操作，左移的位数由 `LEFT` 数组决定。

```cpp
const int LEFT[17]{ 0,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 };
```

####  i 轮置换

将 $C_{i-1}$ 和 $D_{i-1}$ 进行左移操作，左移的位数由 `LEFT[i-1]` 数组决定。

左移后生成 $C_i$ 和 $D_i$，合并，进行置换：

```cpp
const int PC2[49] = { 0,
14,17,11,24,1,5,
3,28,15,6,21,10,
23,19,12,4,26,8,
16,7,27,20,13,2,
41,52,31,37,47,55,
30,40,51,45,33,48,
44,49,39,56,34,53,
46,42,50,36,29,32 };
```

置换后，生成 $K_i$，即第 `i` 轮的子密钥。

### 迭代（Feistel）

将初始置换后的明文分成两部分，每部分 `32位`，分别称为 `L0` 和 `R0`。



#### i 轮迭代

将 $R_{i-1}$ 扩展成 `48位`：

```cpp
const int E[49]{ 0,
32,1,2,3,4,5,
4,5,6,7,8,9,
8,9,10,11,12,13,
12,13,14,15,16,17,
16,17,18,19,20,21,
20,21,22,23,24,25,
24,25,26,27,28,29,
28,29,30,31,32,1 };
```

将 $E(R_{i-1})$ 和 $K_i$ 进行异或操作，得到 `48位` 的结果，将其分成 `8` 组，每组 `6位`。

对于每一组（`6位`）：

* 将 **首位和末位** 作为 **行号**，**中间4位** 作为列号，查 $S_i$ 表得到 `4位` 的结果。
* 将结果转换成二进制，得到 `4位` 的结果。

将 `8` 组 `4位` 的结果合并，得到 `32位` 的结果，进行置换：

```cpp
const int P[33] = { 0,
16,7,20,21,29,12,28,17,
1,15,23,26,5,18,31,10,
2,8,24,14,32,27,3,9,
19,13,30,6,22,11,4,25 };
```

$R_i = $ 置换后的结果 $ \oplus L_{i-1} $
$L_i = R_{i-1}$


### 逆初始置换

将 $L_{16}$ 和 $R_{16}$ 合并，进行逆初始置换，得到密文。

```cpp
const int rIP[65] = { 0,
40,8,48,16,56,24,64,32,
39,7,47,15,55,23,63,31,
38,6,46,14,54,22,62,30,
37,5,45,13,53,21,61,29,
36,4,44,12,52,20,60,28,
35,3,43,11,51,19,59,27,
34,2,42,10,50,18,58,26,
33,1,41,9,49,17,57,25 };
```

---


[验证](https://www.sojson.com/encrypt_des.html)