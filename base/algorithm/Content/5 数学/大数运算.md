---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
--- 

# 高精度
## 加法

<details><summary>string实现 O(n)</summary>

```cpp
string ADD(string &A, string &B, bool flg = 1) { // 默认 正序(正整数)输入 正序输出
    if (flg) reverse(A.begin(), A.end()), reverse(B.begin(), B.end());
    string res; int add = 0;    
    for (int i = 0; i < A.size() || i < B.size() || add; i++) {
        if (i < A.size()) add += A[i] - '0';// 取值
        if (i < B.size()) add += B[i] - '0';// 取的A,B相同低位
        res += add % 10 + '0';              // +
        add /= 10;                          // 进位
    }
    if (flg) reverse(res.begin(), res.end());
    return res; // flg == 0 倒叙输入输出模式 (在连续计算时减少reverse次数,以提升性能)
}
```
</details>


<details><summary>vector实现 O(n)</summary>

```cpp
vector<int> ADD(vector<int> &A, vector<int> &B){
    vector<int> res;
    int add=0;
    for(int i=A.size()-1, j=B.size()-1; i>=0 || j>=0 || add; i--, j--){
        if( i>=0 ) add+=A[i];
        if( j>=0 ) add+=B[j];
        res.push_back(add%10);
        add/=10;
    }
    return res;
}
```
</details>

## 减法

<details><summary>string实现 O(n)</summary>

```cpp
string SUB(string& A, string& B) {  // 正序输入 正序输出
    if(! (A.size()>B.size() || (A.size()==B.size() && A>=B)) ) 
        return "-"+SUB(B, A);   // 非 A > B 的情况
	reverse(A.begin(), A.end()); reverse(B.begin(), B.end());
	string res;                 // 低位向高位减
	for (int i = 0, t = 0; i < A.size(); i++) {
		int ai = A[i] - '0';                // 换成 int
		int bi = i<B.size() ? B[i]-'0' : 0; // B位数不够
		t = ai - bi - t;                    // 减去
		res.push_back((t + 10) % 10 + '0'); // 保证是正数
		if (t < 0) t = 1;                   // 借走了一位
		else t = 0;
	}
	while (res.size() > 1 && res.back() == '0') res.pop_back();
	reverse(res.begin(), res.end());
	return res;
}
```
</details>


## 乘法

<details><summary>string实现</summary>

```cpp

```
</details>


<details><summary>FFT O(nlogn)</summary>

```cpp

```
</details>

## 除法

<details><summary>string实现 O(n)</summary>

```cpp
string div(string& A, int b, int& r) {	// A / b = res ... r 
	string res;	// 正序(正整数)输入 正序输出
	r = 0;
	for (int i = 0; i < A.size(); i++) {
		int ai = A[i] - '0';
		r = r * 10 + ai;            // r从高位下来,故*10
		res.push_back(r / b + '0'); // 整数位压入res
		r %= b;                     // 余数
	}
	while (res.size() > 1 && res.front() == '0') res.erase(res.begin(), res.begin() + 1);
	return res; // 去除前导 0 
}
```
</details>


## 应用

<a href="https://www.acwing.com/problem/content/3456/" target="_blank">AcWing 3453. 整数查询</a>

<details><summary>加法</summary> 

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

string res;

string ADD(string &A, string &B, bool flg = 1) { // 默认 正序输入 正序输出
    if (flg) reverse(A.begin(), A.end()), reverse(B.begin(), B.end());
    string res; int add = 0;    
    for (int i = 0; i < A.size() || i < B.size() || add; i++) {
        if (i < A.size()) add += A[i] - '0';// 取值
        if (i < B.size()) add += B[i] - '0';// 取的A,B相同低位
        res += add % 10 + '0';              // +
        add /= 10;                          // 进位
    }
    if (flg) reverse(res.begin(), res.end());
    return res; // flg == 0 倒叙输入输出模式 (在连续计算时减少reverse次数,以提升性能)
}

int main(){
    string one;
    while(cin>>one)
        res = ADD(res, one);
    cout<<res;
    return 0;
}
```

</details>


<a href="https://www.acwing.com/problem/content/3451/" target="_blank">Acwing 3448. 基本算术</a>

<details><summary>加法进位的次数</summary> 

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int ans;
string ADD(string &A, string &B, bool flg = 1) { // 默认 正序输入 正序输出
    if (flg) reverse(A.begin(), A.end()), reverse(B.begin(), B.end());
    string res; int add = 0;    
    for (int i = 0; i < A.size() || i < B.size() || add; i++) {
        if (i < A.size()) add += A[i] - '0';// 取值
        if (i < B.size()) add += B[i] - '0';// 取的A,B相同低位
        res += add % 10 + '0';              // +
        if(add >= 10) ans++;        // 进位次数统计
        add /= 10;                          // 进位
    }
    if (flg) reverse(res.begin(), res.end());
    return res; // flg == 0 倒叙输入输出模式 (在连续计算时减少reverse次数,以提升性能)
}

void solve(string a, string b){
    ans=0;
    ADD(a, b);
    if(ans==0)
        cout<<"No";
    else
        cout<<ans;
    cout<<" carry operation";
    if(ans<=1) cout<<".\n";
    else cout<<"s.\n";
}

int main(){
    string a, b;
    while(cin>>a>>b, a!="0"||b!="0")
        solve(a, b);
    return 0;
}
```
</details>

