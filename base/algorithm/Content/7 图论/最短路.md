---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
--- 

## 邻接表

### 链式前向星

```cpp
// 定义
int h[N], e[N<<1], ne[N<<1], idx;
// 初始化
idx=0; memset(h, -1, h);
// 增加一条边
void add(int a, int b){
    e[idx]=b, ne[idx]=h[a], h[a]=idx++;
}
// 遍历点 i
for(int j=h[i]; j!=-1; j=ne[j])
    e[j];   // e[j] 是直接连接的那个点

```

### STL大法

```cpp
// 定义
vector<int> g[N];
// 初始化
for(int i=0; i<N; i++) g[i].clear();
// 增加一条边
g[i].push_back(j);
// 遍历
for(auto j: g[i]);
```


## 邻接矩阵

```cpp


```

## Dijkstra

> 将所有点看作未确定最短路
> 将起点的dis[s]=0，其余置为+∞
> 将未确定的点中，选取距离s最近的点进行松弛操作

```cpp
int n, m; // 点、边
vector<PII> edge[100010]; // edge[x]={y,z} x->y=z
int dis[N]; // 最短路
bool st[N]; // 是否已确定最短路
// O(mlogm)
int dijkstra(int s, int e){
    // fst存dis[i] sed存i
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    // 初始化
    memset(dis, 0x3f, sizeof dis);
    dis[s]=0;
    // 起点入队
    heap.push({dis[s], s});
    while(heap.size()){
        auto x=heap.top().sed; // 取最小点
        heap.pop();
        // 在出堆的时候判断、确定是否确定最短路
        if(st[x]) continue;
        st[x]=1; // 确定最短路
        // 对该点进行松弛操作
        for(auto& [y, z]: edge[x])
        if( dis[y]>dis[x]+z ){
            dis[y]=dis[x]+z;
            heap.push({dis[y], y});
        }
    }
    return dis[e];
}
```

## bellman_ford

> 将起点的dis[s]=0，其余置为+∞
> 将所有边进行松弛操作
> 直到某轮迭代中没有执行松弛操作时，退出，或者执行n次

```cpp
int n, m, k; // 最多经过k条边
vector<PII> edge[N];
int dis[N]; // 最短路
int bkup[N]; // 备份，防止串联
// O(nm)
int bellman_ford(int s, int e){
    memset(dis, 0x3f, sizeof dis);
    dis[s]=0;
    for(int i=1; i<=k; i++){ // 最多迭代 k 次
        bool flg=0;
        memcpy(bkup, dis, sizeof dis);
        for(int x=1; x<=n; x++) // 遍历所有边
        for(auto& [y, z]: edge[x]) // 对每条边进行松弛操作
            if( dis[y] > bkup[x] + z){
                dis[y] = bkup[x] + z;
                flg=1;
            }
        if(!flg) break; // 当前没有进行松弛操作
    }
    // 因为存在无穷大引出的边发生松弛操作
    // 而图中存在负权边，因此要做个小小的处理
    if(dis[e]>INF/2) return INF;
    return dis[e];
}
```

## spfa
> 将起点的dis[s]=0，其余置为+∞
> 将被松弛的点加入队列，进行松弛操作
> 通过一个 st[i] 来判断 i 点是否在队列中，防止重复入队

```cpp
int n, m;
vector<PII> edge[N];
int dis[N]; // 最短路
bool st[N]; // 是否在队列中?
//O(nm)
int spfa(int s, int e){
    queue<int> q;
    memset(dis, 0x3f, sizeof dis);
    
    dis[s]=0; // 源点
    st[s]=1; // 在队列中
    q.push(s); // 扔进队列
    
    while(q.size()){
        auto x=q.front();
        q.pop();
        st[x]=0; // 不在队列中
        
        for(auto& [y, z]: edge[x])
            if( dis[y] > dis[x] + z ){
                dis[y] = dis[x] + z;
                if(!st[y]){ // 如果被松弛的点不在队列中
                    st[y]=1;// 就压入队列
                    q.push(y);
                }
            }
    }
    return dis[e];
}
```

## Floyd

>  将自己到达自己的最短路设置为0，其余设置为+∞
> 任意两点，都可以经过任意一点，尝试松弛操作

```cpp
int n, m;
int dis[N][N];
// O(n^3)
void flody(){
    for(int k=1; k<=n; k++)
    for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
        dis[i][j]=min(dis[i][j], dis[i][k]+dis[k][j]);
}
```