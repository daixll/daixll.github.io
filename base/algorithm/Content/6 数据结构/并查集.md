---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
--- 

## 朴素并查集


```cpp
int find(int x){
    if(p[x] != x) p[x] = find(p[x]);
    return p[x]; 
}
```


<details><summary><a href="https://www.luogu.com.cn/problem/P1551" target="_blank">Luogu P1551 亲戚</a> code</summary>

```cpp
#include <iostream>
using namespace std;

const int N=5e3+10;

int p[N];
int n, m, q;

int find(int x){
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    cin>>n>>m>>q;
    for(int i=1; i<=n; i++) p[i] = i;
    for(int i=1; i<=m; i++){
        int a, b; scanf("%d%d", &a, &b);
        p[ find(b) ] = find(a);
    }
    for(int i=1; i<=q; i++){
        int a, b; scanf("%d%d", &a, &b);
        cout<< ((find(a) == find(b)) ? "Yes" : "No") << "\n";
    }

    return 0;
}
```
</details>



<details><summary><a href="https://www.luogu.com.cn/problem/P1536" target="_blank">Luogu P1536 村村通</a> code</summary>

```cpp
#include <iostream>
using namespace std;

const int N=1e3+10;

int p[N];
int n, m;

int find(int x){
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void solve(){
    for(int i=1; i<=n; i++) p[i]=i;
    *p = 0;

    for(int i=1; i<=m; i++){
        int a, b; scanf("%d%d", &a, &b);
        if(find(a) != find(b))
            p[find(a)] = find(b);
    }

    for(int i=1; i<=n; i++)
        if(find(i) == i)  // 统计孤岛
            p[0]++;

    cout<<p[0]-1<<"\n";
}

int main(){
    while(cin>>n , n){
        cin>>m;
        solve();
    }
    return 0;
}
```
</details>


---
## 维护size的并查集



---
## 维护到祖宗节点距离的并查集

