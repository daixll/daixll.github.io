---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
--- 


## LIS 最长上升子序列

> Longest Increasing Subsequence

<details><summary><a href="https://www.luogu.com.cn/problem/B3637" target="_blank">Luogu B3637 最长上升子序列</a> code</summary>

```cpp
#include <iostream>
using namespace std;

const int N=5e3+10;

int a[N], dp[N];
int n;

int main(){
    cin>>n;
    for(int i=1; i<=n; i++) cin>>a[i];
    for(int i=1; i<=n; i++){
        dp[i]=1;
        for(int j=1; j<i; j++)
            if( a[i] > a[j] )
                dp[i] = max(dp[i], dp[j] + 1);
            *dp = max(*dp, dp[i]);
    }
    cout<<(*dp);

    return 0;
}
```
</details>


<details><summary><a href="https://www.luogu.com.cn/problem/T285024" target="_blank">Luogu T285024 最大上升子序列和</a> code</summary>

```cpp
#include <iostream>
using namespace std;

const int N=1e4+10;

int a[N], dp[N];
int n;

int main(){
    cin>>n;
    for(int i=1; i<=n; i++) cin>>a[i];
    for(int i=1; i<=n; i++){
        dp[i]=a[i]; // 和
        for(int j=1; j<i; j++)
            if( a[i] > a[j] )
                dp[i] = max(dp[i], dp[j] + a[i]);   // 和
            *dp = max(*dp, dp[i]);
            
    }
    cout<<(*dp);

    return 0;
}
```
</details>


<details><summary><a href="https://www.luogu.com.cn/problem/U234151" target="_blank">Luogu U234151 怪盗基德的滑翔翼</a> code</summary>

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N=1e2+10;

int a[N], dp[N];
int n;

void solve(){
    memset(a, 0, sizeof a);
    memset(dp, 0, sizeof dp);
    cin>>n;
    for(int i=1; i<=n; i++) scanf("%d", a+i);

    for(int i=1; i<=n; i++){
        dp[i]=1;
        for(int j=1; j<i; j++)
            if( a[i] < a[j] )
                dp[i] = max(dp[i], dp[j]+1);
        *a = max(*a, dp[i]);
    }

    memset(dp, 0, sizeof dp);
    for(int i=n; i>=1; i--){
        dp[i]=1;
        for(int j=n; j>i; j--)
            if( a[i] < a[j] )
                dp[i] = max(dp[i], dp[j]+1);
        *a = max(*a, dp[i]);
    }

    cout<<*a<<"\n";

    return ;
}

int main(){
    int T; cin>>T;
    while(T--) solve();
    return 0;
}
```
</details>


<details><summary><a href="https://www.luogu.com.cn/problem/P1091" target="_blank">Luogu P1091 [NOIP2004 提高组] 合唱队形</a> code</summary>

```cpp
#include <stdio.h>

const int N=110;

int a[N], dp[N], dp2[N];
int n;

int main(){
    scanf("%d", &n);
    for(int i=1; i<=n; i++) scanf("%d", a+i);
    
    // 最长上升子序列
    for(int i=1; i<=n; i++){
        dp[i]=1;
        for(int j=1; j<i; j++)
            if(a[i]>a[j]) dp[i] = dp[i] > dp[j]+1 ? dp[i] : dp[j]+1;
    }
    
    // 最长下降子序列
    for(int i=n; i>=1; i--){
        dp2[i]=1;
        for(int j=n; j>i; j--)
            if(a[i]>a[j]) dp2[i] = dp2[i]> dp2[j]+1 ? dp2[i] : dp2[j]+1;
            
        *dp = *dp > dp[i]+dp2[i]-1 ? *dp : dp[i]+dp2[i]-1;
    }

    printf("%d", n-*dp);
    return 0;
}
```
</details>

--- 

## LCS 最长公共子序列

> Longest Common Subsequence







--- 

## LCIS 最长公共上升子序列

> Longest Common Increasing Subsequence






