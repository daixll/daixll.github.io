---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
---

## 日期问题
<details><summary><a href="https://www.acwing.com/problem/content/description/1231/" target="_blank">AcWing 1229. 日期问题</a> code</summary>

```cpp
#include <iostream>
#include <set>
using namespace std;

int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
bool ck(int y, int m, int d){
    months[2] = 28;
    if(y>=2060 || y<1960) return 0; // 判断年
    if(m<1 || m>12) return 0;       // 判断月
    if(y%400==0 || (y%4==0 && y%100!=0)) months[2] = 29; 
    if(d<1 || d>months[m]) return 0;// 判断日
    return 1;
}

int main(){
    int y, m, d;
    scanf("%d/%d/%d", &y, &m, &d);

    set<int> pq;
    if(ck(1900+y, m, d)) pq.insert( (1900+y)*1e4 + m*1e2 + d);
    if(ck(2000+y, m, d)) pq.insert( (2000+y)*1e4 + m*1e2 + d);
    if(ck(1900+d, y, m)) pq.insert( (1900+d)*1e4 + y*1e2 + m);
    if(ck(2000+d, y, m)) pq.insert( (2000+d)*1e4 + y*1e2 + m);
    if(ck(1900+d, m, y)) pq.insert( (1900+d)*1e4 + m*1e2 + y);
    if(ck(2000+d, m, y)) pq.insert( (2000+d)*1e4 + m*1e2 + y);
    for(auto x: pq) printf("%d-%02d-%02d\n", x/10000, x%10000/100, x%100);

    return 0;
}
```
</details>

<details><summary><a href="https://www.acwing.com/problem/content/description/3394/" target="_blank">AcWing 3391. 今年的第几天？</a> code</summary>

```cpp
#include <iostream>
using namespace std;

int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
bool ck(int y, int m, int d){
    months[2] = 28;
    if(m<1 || m>12) return 0;       // 判断月
    if(y%400==0 || (y%4==0 && y%100!=0)) months[2] = 29; 
    if(d<1 || d>months[m]) return 0;// 判断日
    return 1;
}

int main(){
    int y, m, d;
    while(cin>>y>>m>>d){
        int res=0, day=m*100+d;
        for(int i=101; i<=day; i++)
            if(ck(y, i/100, i%100))
                res++;
        cout<<res<<"\n";
    }
    
    return 0;
}
```
</details>

<details><summary><a href="https://www.acwing.com/problem/content/description/3492/" target="_blank">AcWing 3489. 星期几</a> code</summary>

> 基姆•拉尔森公式可以由公历的年月日推导出当天的星期
> `w = (d + 2m + 3(m + 1) / 5 + y + y / 4 - y / 100 + y / 400 + 1) % 7`
> * d 为日期, 范围是1-31
> * m 为月份, 范围是3-14, 当年的1, 2月需处理为上一年的13, 14月(即y-=1, m+=1或2)
> * y 为年份, 当月份为1, 2时, y-=1
> * w 为星期, 范围是为0-6, 星期日用0表示, 星期一为1, 以此类推, 星期六为6

```cpp
#include <algorithm>
#include <cstring>
#include <iostream>
#include <map>

using namespace std;

int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
map<string, int> month_name = {
    {"January", 1},{"February", 2},{"March", 3},{"April", 4},
    {"May", 5},{"June", 6},{"July", 7},{"August", 8},
    {"September", 9},{"October", 10},{"November", 11},{"December", 12} };

string week_name[7] = {
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"};

int main() {
    int d, m, y;
    string str;
    while (cin >> d >> str >> y) {
        m = month_name[str];
        if(m==1||m==2) m += 12, y--;
        cout<<week_name[ (d + 2 *m + 3 *(m+1)/5 + y + y/4 -y /100 + y/400)%7 ] << endl;
    }

    return 0;
}

```
</details>

---

## 回文问题

<details><summary><a href="https://www.acwing.com/problem/content/description/2870/" target="_blank">AcWing 2867. 回文日期</a> code</summary>

```cpp
#include <iostream>
using namespace std;

int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
bool ck(int y, int m, int d){
    months[2] = 28;
    if(m<1 || m>12) return 0;       // 判断月
    if(y%400==0 || (y%4==0 && y%100!=0)) months[2] = 29; 
    if(d<1 || d>months[m]) return 0;// 判断日
    return 1;
}

bool flg=0;

int main(){
    int start; cin>>start;
    int d, m, y=start/10000;
    
    for(; ; y++){
        m = y%10*10 + y%100/10;
        d = y/100%10*10 + y/1000;
        
        if(ck(y, m, d) && y*1e4+m*1e2+d > start){
            
            if(!flg){
                printf("%d%02d%02d\n", y, m, d);   
                flg=1;
            }
            
            if(m == d && m/10 != m%10){
                printf("%d%02d%02d\n", y, m, d); 
                break;
            }
        }
    }
    return 0;
}
```
</details>

---
## 约瑟夫环

<details><summary><a href="https://www.acwing.com/problem/content/description/3562/" target="_blank">AcWing 3559. 围圈报数</a> code</summary>

```cpp
#include <iostream>
#include <cstring>
using namespace std;

void solve(){
    int n; cin>>n;
    bool a[n];
    memset(a, true, sizeof a);
    
    int k=0, cnt=0;
    for(int i=0; cnt<n; i++){
        
        if(a[i]){
            k++;
            
            if(k==3){
                printf("%d ", i+1);
                a[i]=0;
                cnt++;
                k=0;
            }
        }
        
        // 到达首位
        if(i==n-1) i=-1;    
    }
    
    puts("");
    
    return ;
}

int main(){
    int T; cin>>T; while(T--)
    solve();
    return 0;
}
```
</details>

---
## 格雷码问题



---
## 杨辉三角形

<details><summary><a href="https://www.acwing.com/problem/content/description/3421/" target="_blank">AcWing 3418. 杨辉三角形</a> code</summary>

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3,"Ofast","inline")

#include <iostream>
#include <cmath>
using namespace std;

const int INF=0x3f3f3f3f;

typedef long long LL;

LL f[30][30];

LL c(int a, int b){
    LL res=1;
    for(int i=a, j=1; j<=b; i--, j++)
        res=res*i/j;
    return res;
}

int main(){
    LL n;
    cin>>n;
    if(n==1){
        cout<<n;
        return 0;
    }
    
    f[0][0]=1;
    for(int i=1; i<=20; i++){
        f[i][0]=1;
        for(int j=1; j<=i; j++){
            // 计算
            f[i][j]=f[i-1][j-1]+f[i-1][j];
            
            // 大于1e9无意义，直接设置为INF，防止下面的值爆LL
            if(f[i][j]>1e9) f[i][j]=INF; 
            
            // 找到目标值
            if(f[i][j]==n){
                // (1 + (i+1 - 1))*(i)/2  (a1+an)*(n)/2  （首项+末项）*（项数）/ 2
                cout<<1LL*(i+1)*(i)/2+j+1;
                return 0;
            }
        }    
    }

    /*  顺序找会超时
    for(int i=2001; i<=n; i++){
        if(i==n){
            cout<<1LL*(i+1)*(i)/2+2;
            return 0;
        }
        if( i*(i-1)/2 ==n){
            cout<<1LL*(i+1)*(i)/2+3;
            return 0;
        }
    }
    */
    
    // 答案一定在c(i,1) c(i,2)中
    LL i=sqrt(2*n)+1;
    
    if( c(i,2) == n)
        cout<<i*(i+1)/2+3; // c(i,2)
    else
        cout<<n*(n+1)/2+2; // c(n,1)
    
    return 0;
}
```
</details>

---
## 表达式求值问题



---
## 其他