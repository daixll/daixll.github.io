---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
---

<img src="https://cdn.acwing.com/media/article/image/2020/12/05/41924_1a3c844236-sort.png" width="500">

[图片来源: 十大排序算法总结](https://www.acwing.com/solution/content/26513/)

---

# STL


## 排序

<details><summary>sort()</summary> 

`O(nlogn)`
```cpp
// int a[N] // 从 1 开始存
sort(a+1, a+1+n);

// vector<int> b;
sort(b.begin(), b.end());

// 从大到小
sort(a+1, a+1+n, greater<int>());
```
</details>

<details><summary>sort() 自定义cmp()</summary> 

```cpp
bool cmp(PII a, PII b){ // 需要比较的两个元素
    if(a.first > b.first) return 1; // first更大的在前面
    if(a.first < b.first) return 0; // first更小的在后面
    if(a.second < b.second) return 1;   // second更小的在前面
    if(a.second > b.second) return 0;   // second更大的在后面
    return 0;   // first降序, second升序
}

void solve(){
    sort(a+1, a+1+n, cmp);
    return ;
}
```
</details>

## 第k大数

<details><summary>nth_element()</summary>

`O(n)`

```cpp
// int a[N]
nth_element(a+1, a+5, a+1+n);

// 使用自定义cmp规则
nth_element(a+1, a+5, a+1+n, cmp);
```
</details>


---

# 快速排序

<details><summary><a href="https://www.luogu.com.cn/problem/P1177" target="_blank">Luogu P1177 【模板】快速排序</a> code</summary> 

```cpp
#include <iostream>
using namespace std;

const int N=1e5+10;

int n;
int a[N];

void quick_sort(int _a[], int l, int r){
    if(l>=r) return ;               // 区间为空, 或只有一个
    int i=l-1, j=r+1, x=_a[l+r>>1]; // 边界取两侧, 标的选中间
    while(i<j){                 
        do i++; while(_a[i]<x);     // 定位到一个>=x的数
        do j--; while(_a[j]>x);     // 定位到一个<=x的数
        if(i<j) swap(_a[i], _a[j]); // 如果两数还未相遇, swap
    }                               // 递归左边, 递归右边
    quick_sort(_a, l, j), quick_sort(_a, j+1, r);
}

int main(){
    cin>>n;
    for(int i=1; i<=n; i++) scanf("%d", a+i);
    quick_sort(a, 1, n);
    for(int i=1; i<=n; i++) printf("%d ", a[i]);
    return 0;
}
```
</details>


<details><summary><a href="https://www.luogu.com.cn/problem/P1923" target="_blank">Luogu P1923 【深基9.例4】求第 k 小的数</a> code</summary> 

```cpp
#include <iostream>
using namespace std;

const int N=5e6+10;
int a[N];
int n, k;

void quick_select(int _a[], int l, int r, int k){
    if(l>=r) return ;               // 区间为空, 或只有一个
    int i=l-1, j=r+1, x=_a[l+r>>1]; // 边界取两侧, 标的选中间
    while(i<j){                 
        do i++; while(_a[i]<x);     // 定位到一个>=x的数
        do j--; while(_a[j]>x);     // 定位到一个<=x的数
        if(i<j) swap(_a[i], _a[j]); // 如果两数还未相遇, swap
    }   // j-l+1 指 此数在这个区间中的位置
    if(k<=j-l+1) quick_select(_a, l, j, k); // 如果k在左边, 递归左边
    else quick_select(_a, j+1, r, k-j+l-1); // 反之右边
}

int main(){
    cin>>n>>k;
    for(int i=1; i<=n; i++) scanf("%d", a+i);
    quick_select(a, 1, n, k+1);
    printf("%d", a[k+1]);
    
    return 0;
}
```
</details>




---

# 归并排序

<details><summary>模板</summary> 

```cpp
void merge_sort(int _a[], int l, int r){
    if(l>=r) return ;
    int mid=l+r>>1;         // 递归处理左右两边
    merge_sort(a, l, mid), merge_sort(a, mid+1, r);
    int tmp[r-l+1];
    int k=0, i=l, j=mid+1;  // i, j双指针
    while(i<=mid && j<=r)   // 将更小的放在左边
        if(_a[i] <= _a[j])  tmp[k++]=_a[i++];
        else                tmp[k++]=_a[j++];// ans+=mid-i+1; // 统计逆序对数量
    while(i<=mid)   tmp[k++]=_a[i++];   // 放回
    while(j<=r)     tmp[k++]=_a[j++];
    for(int i=l, j=0; i<=r; i++, j++) _a[i]=tmp[j]; 
}
```
</details>



<details><summary><a href="https://www.luogu.com.cn/problem/P1908" target="_blank">Luogu P1908 逆序对</a> code</summary> 

```cpp
#include <iostream>
using namespace std;

const int N=5e5+10;

int a[N];
int n;

long long ans;
void merge_sort(int _a[], int l, int r){
    if(l>=r) return ;
    int mid=l+r>>1;         // 递归处理左右两边
    merge_sort(a, l, mid), merge_sort(a, mid+1, r);
    int tmp[r-l+1];
    int k=0, i=l, j=mid+1;  // i, j双指针
    while(i<=mid && j<=r)   // 将更小的放在左边
        if(_a[i] <= _a[j])  tmp[k++]=_a[i++];
        else                tmp[k++]=_a[j++], ans+=mid-i+1; // 统计逆序对数量
    while(i<=mid)   tmp[k++]=_a[i++];   // 放回
    while(j<=r)     tmp[k++]=_a[j++];
    for(int i=l, j=0; i<=r; i++, j++) _a[i]=tmp[j]; 
}

int main(){
    cin>>n;
    for(int i=1; i<=n; i++) scanf("%d", a+i);
    merge_sort(a, 1, n);
    printf("%lld\n", ans);
    return 0;
}
```
</details>
