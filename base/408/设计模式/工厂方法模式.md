---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
---

## 含义

* 工厂方法模式(Factory Method Pattern)又称为工厂模式, 也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式, 它属于类创建型模式

* 在工厂方法模式中, 工厂父类负责定义创建产品对象的公共接口, 而工厂子类则负责生成具体的产品对象

* 目的是将产品类的实例化操作`延迟`到工厂子类中完成, 即通过工厂子类来确定究竟应该实例化哪一个具体产品类

## 解决的问题

这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品; 当有新产品加入时, 新建具体工厂继承抽象工厂, 而不用修改任何一个类 `有效避免简单工厂在工厂类中又臭又长的if...else`

## UML类图及时序图

![](https://raw.githubusercontent.com/kiddxl/dxlkid/main/daixll/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png)

## 代码实例

抽象产品
```cpp
class 产品 {
public:
	virtual std::string 产品名字() = 0;
	产品() {};
	~产品() {};
};
```

具体产品
```cpp
class 手机 : public 产品 {
public:
	std::string 产品名字() {
		return "手机";
	}
	手机() {};
	~手机() {};
};
```

抽象工厂
```cpp
class 工厂 {
public:
	virtual 产品* 制造产品() = 0;
	工厂() {};
	~工厂() {};
};
```

具体工厂
```cpp
class 手机厂 :public 工厂 {
public:
	手机* 制造产品() {
		return new 手机();
	}
	手机厂() {};
	~手机厂() {};
};
```

```cpp
int main() {
	工厂* 龙龙的手机工厂 = new 手机厂();
	产品* 佳佳的小手机 = 龙龙的手机工厂->制造产品();

	std::cout << 佳佳的小手机->产品名字();

	delete 龙龙的手机工厂;
	delete 佳佳的小手机;
	return 0;
}
```

## 优点

* 只需要关心工厂, 无需关心创建细节

## 缺点

* 增加了类的数量, 增加了系统复杂度

* 引入了抽象层, 增加了系统的抽象性和理解难度

## 典型应用

日志记录器

支持文件记录、数据库记录等不同记录方式