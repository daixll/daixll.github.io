---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
---

## 含义

提供一个创建一系列相关或相互依赖对象的接口, 而无须指定它们具体的类

## 解决的问题

当需要一个工厂提供多种产品, 而不是单一的产品对象(相较于工厂方法模式)

> * 产品等级结构: 如 `电视` 和 `电视的子类`(小米电视, 三星电视, 索尼电视) 
> * 产品族: 同一个工厂生成的 `小米电视`, `小米手机`, `小米电脑`

![](https://raw.githubusercontent.com/kiddxl/dxlkid/main/daixll/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13_1.png)

## UML类图及时序图

![](https://raw.githubusercontent.com/kiddxl/dxlkid/main/daixll/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png)

## 代码实例

产品等级结构 `电视` 和 `各个品牌的电视`
```cpp
// 抽象类
class 电视 {
public:
	virtual std::string 尺寸() = 0;
	电视() {};
	~电视() {};
};

// 具体类
class oppo电视 : public 电视 {
public:
	std::string 尺寸() {
		return "88寸";
	}
	oppo电视() {};
	~oppo电视() {};
};

class 三星电视 : public 电视 {
public:
	std::string 尺寸() {
		return "32寸";
	}
	三星电视() {};
	~三星电视() {};
};
```

产品等级结构 `手机` 和 `各个品牌的手机`
```cpp
// 抽象类
class 手机 {
public:
	virtual std::string 芯片() = 0;
	手机() {};
	~手机() {};
};

// 具体类
class oppo手机 : public 手机 {
public:
	std::string 芯片() {
		return "马里亚纳海沟";
	}
	oppo手机() {};
	~oppo手机() {};
};
class 三星手机 : public 手机 {
public:
	std::string 芯片(){
		return "猎户座";
	}
	三星手机() {};
	~三星手机() {};
};
```

产品族 同一个工厂生产的
```cpp
// 抽象类
class 品牌 {
public:
	virtual 电视* 制造电视() = 0;
	virtual 手机* 制造手机() = 0;
	品牌() {};
	~品牌() {};
};

// 具体类
class oppo : public 品牌 {
public:
	电视* 制造电视() {
		return new oppo电视();
	}
	手机* 制造手机() {
		return new oppo手机();
	}
	oppo() {};
	~oppo() {};
};
class 三星 : public 品牌 {
public:
	电视* 制造电视() {
		return new 三星电视();
	}
	手机* 制造手机() {
		return new 三星手机();
	}
	三星() {};
	~三星() {};
};
```

```cpp
int main() {
	三星* 三星重庆分厂 = new 三星();
	oppo* oppo重庆分厂 = new oppo();

	手机* 小精灵的小手机 = oppo重庆分厂->制造手机();
	电视* 佳佳的大电视 = 三星重庆分厂->制造电视();

	std::cout << 小精灵的小手机->芯片() << "\n";
	std::cout << 佳佳的大电视->尺寸();
	return 0;
}
```

## 优点

当一个产品族中的多个对象被设计成一起工作时, 它能保证客户端始终只使用同一个产品族中的对象

## 缺点

产品族扩展非常困难, 要增加一个系列的某一产品, 既要在抽象类里加代码, 又要在具体的类里加代码

## 典型应用