---
html:
    toc: true           # 打开侧边目录
    toc_depth: 6        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
--- 

## 含义

* 简单工厂模式(Simple Factory Pattern): 又称为静态工厂方法(Static Factory Method)模式, 它属于类创建型模式
* 在简单工厂模式中, 可以根据参数的不同返回不同类的实例
* 简单工厂模式专门定义一个类来负责创建其他类的实例, 被创建的实例通常都具有共同的父类

## 解决的问题

将“类实例化的操作”与“使用对象的操作”分开, 让使用者不用知道创建逻辑就可以实例化出所需要的“产品”类, 从而避免了在客户端代码中显式指定, 实现了解耦

## UML类图及时序图

![](https://raw.githubusercontent.com/kiddxl/dxlkid/main/daixll/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png)

## 代码实例

抽象产品
```cpp
class 产品
{
public:
	// 提供接口框架的纯虚函数
	virtual std::string 产品名字() = 0;
	产品() {};
	~产品() {};
};
```

具体产品
```cpp
// 三个实际产品
class 电脑 : public 产品 {
public:
	电脑() {};
	~电脑() {};
	std::string 产品名字() {
		return "电脑";
	};
};

class 手机 : public 产品 {
public:
	手机() {};
	~手机() {};
	std::string 产品名字() {
		return "手机";
	};
};

class 平板 : public 产品 {
public:
	平板() {};
	~平板() {};
	std::string 产品名字() {
		return "平板";
	};
};
```

具体工厂
```cpp
class 工厂
{
public:
	工厂() {};
	~工厂() {};
	产品* 制造产品(std::string 产品名) {
		if (产品名 == "电脑")
			return new 电脑;
		if (产品名 == "手机")
			return new 手机;
		if (产品名 == "平板")
			return new 平板;
		return NULL;
	};
};
```

```cpp
int main() {
	工厂* 龙龙的血汗工厂 = new 工厂();
	产品* 佳佳的电脑 = 龙龙的血汗工厂->制造产品("电脑");

	std::cout << 佳佳的电脑->产品名字();

	return 0;
}
```

## 优点

* 工厂类含有必要的判断逻辑, 可以决定在什么时候创建哪一个产品类的实例, 客户端可以免除直接创建产品对象的责任, 而仅仅“消费”产品; 简单工厂模式通过这种做法实现了对责任的分割, 它提供了专门的工厂类用于创建对象

* 客户端无须知道所创建的具体产品类的`类名`, 只需要知道具体产品类所对应的参数即可, 对于一些复杂的类名, 通过简单工厂模式可以减少使用者的记忆量

* 通过引入配置文件, 可以在不修改任何客户端代码的情况下更换和增加新的具体产品类, 在一定程度上提高了系统的灵活性

## 缺点

* 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响

* 使用简单工厂模式将会增加系统中类的个数, 在一定程序上增加了系统的复杂度和理解难度

* 系统扩展困难, 一旦添加新产品就不得不修改工厂逻辑, 在产品类型较多时, 有可能造成工厂逻辑过于复杂, 不利于系统的扩展和维护

* 简单工厂模式由于使用了静态工厂方法, 造成工厂角色无法形成基于继承的等级结构

## 典型应用

