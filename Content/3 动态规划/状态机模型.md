---
html:
    toc: true           # 打开侧边目录
    toc_depth: 3        # 打开的目录层级
    toc_float: true     # 侧边悬停
    collapsed: true     # 只显示高级别标题(2)
    smooth_scroll: true # 页面滚动,标题变化
    number_sections: false  # 显示标题编号
    theme: united
--- 


# 打家劫舍问题

## 打家劫舍 1 ( 序列不相邻 )
<a href="https://leetcode.cn/problems/house-robber/" target="_blank">LC 198. 打家劫舍</a>

<details><summary>状态机DP O(n)</summary> 

```cpp
const int N=1e2+10;
int dp[N][2];       // dp[i][0] 表示没偷的最大价值
int n;              // dp[i][1] 表示偷了的最大价值
                    
class Solution {
public:
    int rob(vector<int>& nums) {
        n = nums.size();
        nums.insert(nums.begin(), 0);

        dp[1][0] = 0;           // 如果没偷, 那么第 1 家为 0 
        dp[1][1] = nums[1];     // 如果偷了, 那么第 1 家为 nums[1]

        for(int i=2; i<=n; i++){
            dp[i][1] = dp[i-1][0] + nums[i];        // 如果要偷, 肯定是从 [前一家][没偷] 转移过来
            dp[i][0] = max(dp[i-1][1], dp[i-1][0]); // 如果不偷, 肯定是从 [前一家][偷了] 转移过来
        }

        return max(dp[n][0], dp[n][1]);
    }
};
```
</details>


<details><summary>线性DP O(n)</summary> 

```cpp
const int N=1e2+10;
int dp[N];      // dp[i] 表示前 i 个房子能偷取的最大价值
int n;            
                    
class Solution {
public:
    int rob(vector<int>& nums) {
        n = nums.size();
        nums.insert(nums.begin(), 0);

        dp[1]=nums[1];              // 前 1 个房子肯定是nums[1]

        for(int i=2; i<=n; i++)
            dp[i]=max(dp[i-1], dp[i-2]+nums[i]);

        // 在 i==2 的时候,
        //      dp[i-1] == nums[i-1]
        //      dp[i-2]+nums[i] == nums[i]
        // 因此dp[2] = max(nums[1], nums[2])
        // 注意, 此代码不能理解为:
        //      偷 第[i-1] 房子
        //      偷 第[i-2] 房子 + 第[i] 房子
        return dp[n];
    }
};
```
</details>

<details><summary>滚动数组优化 O(n)</summary> 

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int a[3]={0};
        a[1]=nums[0];

        for(int i=1; i<nums.size(); i++){
            a[2] = max(a[1], a[0]+nums[i]);
            
            a[0]=a[1];
            a[1]=a[2];
        }

        return a[1];
    }
};
```
</details>

<details><summary>复用nums优化空间 O(n)</summary> 

```cpp
class Solution {
public:
    int rob(vector<int>& f) {
        if(f.size()>=2) f[1]=max(f[0], f[1]);
        for(int i=2; i<f.size(); i++)
            f[i] = max(f[i-1], f[i-2]+f[i]);
        return f[f.size()-1];
    }
};
```
</details>

## 打家劫舍 2 ( 环形不相邻 )
<a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank">LC 213. 打家劫舍 II</a>

<details><summary>分类讨论 O(n)</summary> 

```cpp
class Solution {
public:
    int robi(vector<int>& f) {
        if(f.size()>=2) f[1]=max(f[0], f[1]);
        for(int i=2; i<f.size(); i++)
            f[i] = max(f[i-1], f[i-2]+f[i]);
        return f[f.size()-1];
    }
    int rob(vector<int>& f) {
        if(f.size()==1) return f[0];
        vector<int> f1, f2;
        f1.assign(f.begin()+1, f.end());    // 情况1 第 1 家不考虑
        f2.assign(f.begin(), f.end()-1);    // 情况2 第 n 家不考虑
        return max(robi(f1), robi(f2));
    }
};
```

</details>

## 打家劫舍 3 ( 树形不相邻 )
<a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank">337. 打家劫舍 III</a>

<details><summary>树形DP O(n)</summary> 

```cpp
#define fst first
#define sed second
typedef pair<int, int> PII;

class Solution {
public:
    PII dfs(TreeNode* t){
        if(!t) return {0,0};
        PII l = dfs(t->left);
        PII r = dfs(t->right);
        return {            // 返回 t 结点(不偷与偷)的最大值    
            l.sed+r.sed,    // 不偷: 左右子树偷了的价值和
            max(l.fst+r.fst+t->val, l.sed+r.sed)
        };                  //   偷: 左右子树不偷+t偷 与 左右子树偷了的价值 取max
    }

    int rob(TreeNode* root) {
        PII res = dfs(root);
        return max(res.fst, res.sed);   // fst不偷, sed偷
    }
};
```
</details>

# 股票买卖问题